var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, NgZone, Renderer2 } from '@angular/core';
import { thfChartAngleStepInterval, thfChartCompleteCircle, thfChartPadding, thfChartStartAngle } from './thf-chart-pie.constant';
import { ThfChartDynamicTypeComponent } from '../thf-chart-dynamic-type.component';
var ThfChartPieComponent = /** @class */ (function (_super) {
    __extends(ThfChartPieComponent, _super);
    function ThfChartPieComponent(el, ngZone, renderer) {
        var _this = _super.call(this) || this;
        _this.el = el;
        _this.ngZone = ngZone;
        _this.renderer = renderer;
        _this.chartItemsEndAngleList = [];
        _this.svgPathElementsList = [];
        return _this;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} totalValue
     * @return {?}
     */
    ThfChartPieComponent.calculateEndAngle = /**
     * @private
     * @param {?} value
     * @param {?} totalValue
     * @return {?}
     */
    function (value, totalValue) {
        return value / totalValue * (Math.PI * 2);
    };
    /**
     * @return {?}
     */
    ThfChartPieComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeWindowResizeListener();
        this.removeWindowScrollListener();
        this.animationRunning = false;
    };
    /**
     * @return {?}
     */
    ThfChartPieComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.chartInitSetup();
        this.setEventListeners();
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.animationSetup = /**
     * @private
     * @return {?}
     */
    function () {
        this.chartItemStartAngle = thfChartStartAngle;
        this.chartItemEndAngle = this.chartItemsEndAngleList[0];
        this.animationRunning = true;
        this.drawPathInit();
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.calculateAngleRadians = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.series.forEach(function (serie, index) {
            return _this.chartItemsEndAngleList[index] = ThfChartPieComponent.calculateEndAngle(serie.value, _this.totalValue);
        });
    };
    /**
     * @private
     * @param {?} angleCurrentPosition
     * @return {?}
     */
    ThfChartPieComponent.prototype.calculateCurrentEndAngle = /**
     * @private
     * @param {?} angleCurrentPosition
     * @return {?}
     */
    function (angleCurrentPosition) {
        /** @type {?} */
        var isSerieDrawCompleted = this.chartItemStartAngle + angleCurrentPosition > this.chartItemStartAngle + this.chartItemEndAngle;
        if (isSerieDrawCompleted) {
            return (this.chartItemStartAngle + this.chartItemEndAngle) - thfChartCompleteCircle;
        }
        else {
            return this.chartItemStartAngle + angleCurrentPosition;
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfChartPieComponent.prototype.changeTooltipPosition = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.tooltipElement && this.tooltipElement.classList.contains('thf-invisible')) {
            this.showTooltip();
        }
        /** @type {?} */
        var tooltipPositions = this.setTooltipPositions(event);
        this.renderer.setStyle(this.tooltipElement, 'left', tooltipPositions.left + "px");
        this.renderer.setStyle(this.tooltipElement, 'top', tooltipPositions.top + "px");
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.chartInitSetup = /**
     * @private
     * @return {?}
     */
    function () {
        this.calculateSVGContainerDimensions(this.chartWrapper, this.chartHeader, this.chartLegend);
        this.calculateTotalValue();
        this.calculateAngleRadians();
        this.createSVGElements();
        this.animationSetup();
    };
    /**
     * @private
     * @param {?} index
     * @param {?} serie
     * @param {?} svgPathsWrapper
     * @return {?}
     */
    ThfChartPieComponent.prototype.createPath = /**
     * @private
     * @param {?} index
     * @param {?} serie
     * @param {?} svgPathsWrapper
     * @return {?}
     */
    function (index, serie, svgPathsWrapper) {
        /** @type {?} */
        var svgPath = this.renderer.createElement('svg:path', 'svg');
        this.renderer.setAttribute(svgPath, 'class', 'thf-path-item');
        this.renderer.setAttribute(svgPath, 'fill', this.colors[index]);
        this.renderer.setAttribute(svgPath, 'data-tooltip-category', serie.category);
        this.renderer.setAttribute(svgPath, 'data-tooltip-value', serie.value);
        svgPathsWrapper.appendChild(svgPath);
        this.renderer.appendChild(this.svgElement, svgPathsWrapper);
        this.svgPathElementsList.push(svgPath);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.createPaths = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var svgPathsWrapper = this.renderer.createElement('svg:g', 'svg');
        this.series.forEach(function (serie, index) { return _this.createPath(index, serie, svgPathsWrapper); });
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.createSVGElements = /**
     * @private
     * @return {?}
     */
    function () {
        this.svgElement = this.renderer.createElement('svg:svg', 'svg');
        this.renderer.setAttribute(this.svgElement, 'viewBox', "0 0 " + this.chartWrapper + " " + this.centerX * 2);
        this.renderer.setAttribute(this.svgElement, 'preserveAspectRatio', 'xMidYMin meet');
        this.renderer.setAttribute(this.svgElement, 'class', 'thf-chart-svg-element');
        this.renderer.setAttribute(this.svgElement, 'width', "" + (this.chartWrapper - thfChartPadding * 2));
        this.renderer.setAttribute(this.svgElement, 'height', "" + this.svgHeight);
        this.svgContainer.nativeElement.appendChild(this.svgElement);
        this.createPaths();
    };
    /**
     * @private
     * @param {?} path
     * @param {?} chartItemStartAngle
     * @param {?} chartItemEndAngle
     * @return {?}
     */
    ThfChartPieComponent.prototype.drawPath = /**
     * @private
     * @param {?} path
     * @param {?} chartItemStartAngle
     * @param {?} chartItemEndAngle
     * @return {?}
     */
    function (path, chartItemStartAngle, chartItemEndAngle) {
        /** @type {?} */
        var largeArc = (chartItemEndAngle - chartItemStartAngle) % (Math.PI * 2) > Math.PI ? 1 : 0;
        /** @type {?} */
        var startX = this.centerX + Math.cos(chartItemStartAngle) * this.centerX;
        /** @type {?} */
        var startY = this.centerX + Math.sin(chartItemStartAngle) * this.centerX;
        /** @type {?} */
        var endX = this.centerX + Math.cos(chartItemEndAngle) * this.centerX;
        /** @type {?} */
        var endY = this.centerX + Math.sin(chartItemEndAngle) * this.centerX;
        /** @type {?} */
        var pathCoordinates = [
            'M', startX, startY,
            'A', this.centerX, this.centerX, 0, largeArc, 1, endX, endY,
            'L', this.centerX, this.centerX,
            'Z'
        ].join(' ');
        return path.setAttribute('d', pathCoordinates);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.drawPathInit = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.animationRunning) {
            return;
        }
        else {
            this.ngZone.runOutsideAngular(function () { return _this.drawSeries(); });
        }
    };
    /**
     * @private
     * @param {?=} currentSerieIndex
     * @param {?=} angleCurrentPosition
     * @return {?}
     */
    ThfChartPieComponent.prototype.drawSeries = /**
     * @private
     * @param {?=} currentSerieIndex
     * @param {?=} angleCurrentPosition
     * @return {?}
     */
    function (currentSerieIndex, angleCurrentPosition) {
        if (currentSerieIndex === void 0) { currentSerieIndex = 0; }
        if (angleCurrentPosition === void 0) { angleCurrentPosition = 0; }
        /** @type {?} */
        var isFinishedDrawingCurrentSeries = angleCurrentPosition > this.chartItemEndAngle;
        /** @type {?} */
        var isFinishedDrawingAllSeries = currentSerieIndex === this.svgPathElementsList.length;
        if (isFinishedDrawingAllSeries) {
            return;
        }
        if (isFinishedDrawingCurrentSeries) {
            this.chartItemStartAngle = this.chartItemStartAngle + this.chartItemEndAngle;
            currentSerieIndex++;
            this.chartItemEndAngle = this.chartItemsEndAngleList[currentSerieIndex];
            angleCurrentPosition = 0;
        }
        else {
            angleCurrentPosition += thfChartAngleStepInterval;
            this.drawPath(this.svgPathElementsList[currentSerieIndex], this.chartItemStartAngle, this.calculateCurrentEndAngle(angleCurrentPosition));
        }
        window.requestAnimationFrame(this.drawSeries.bind(this, currentSerieIndex, angleCurrentPosition));
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfChartPieComponent.prototype.emitEventOnEnter = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onSerieHover.next(event);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.onMouseClick = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var serieOnClick = { category: this.chartElementCategory, value: this.chartElementValue };
        this.onSerieClick.next(serieOnClick);
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfChartPieComponent.prototype.onMouseEnter = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.tooltipElement = this.chartBody.nativeElement.lastChild;
        this.chartElementCategory = event.target.getAttributeNS(null, 'data-tooltip-category');
        this.chartElementValue = event.target.getAttributeNS(null, 'data-tooltip-value');
        this.tooltipText = this.chartElementCategory + ": " + this.chartElementValue;
        this.showTooltip();
        this.changeTooltipPosition(event);
        /** @type {?} */
        var serieOnEnter = { category: this.chartElementCategory, value: this.chartElementValue };
        this.emitEventOnEnter(serieOnEnter);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.onWindowResize = /**
     * @private
     * @return {?}
     */
    function () {
        this.calculateSVGContainerDimensions(this.chartWrapper, this.chartHeader, this.chartLegend);
        this.renderer.setAttribute(this.svgElement, 'width', "" + (this.chartWrapper - thfChartPadding * 2));
        this.renderer.setAttribute(this.svgElement, 'height', "" + this.svgHeight);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.removeTooltip = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.tooltipElement) {
            this.renderer.addClass(this.tooltipElement, 'thf-invisible');
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.removeWindowResizeListener = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.windowResizeListener) {
            this.windowResizeListener();
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.removeWindowScrollListener = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.windowScrollListener) {
            this.windowScrollListener();
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.setEventListeners = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var chartSeries = this.el.nativeElement.querySelectorAll('.thf-path-item');
        chartSeries = Array.from(chartSeries);
        chartSeries.forEach(function (serie) {
            _this.renderer.listen(serie, 'click', _this.onMouseClick.bind(_this));
            _this.renderer.listen(serie, 'mouseenter', _this.onMouseEnter.bind(_this));
            _this.renderer.listen(serie, 'mousemove', _this.changeTooltipPosition.bind(_this));
            _this.renderer.listen(serie, 'mouseleave', _this.removeTooltip.bind(_this));
        });
        this.windowResizeListener = this.renderer.listen(window, 'resize', this.onWindowResize.bind(this));
        this.windowScrollListener = this.renderer.listen(this.checkingIfScrollsWithThfPage(), 'scroll', this.removeTooltip.bind(this));
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.checkingIfScrollsWithThfPage = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var thfPageContent = document.getElementsByClassName('thf-page-content');
        return thfPageContent.length ? thfPageContent[0] : window;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfChartPieComponent.prototype.setTooltipPositions = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var displacement = 8;
        return {
            left: event.clientX - this.tooltipElement.offsetWidth / 2,
            top: event.clientY - this.tooltipElement.offsetHeight - displacement
        };
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.showTooltip = /**
     * @private
     * @return {?}
     */
    function () {
        this.renderer.removeClass(this.tooltipElement, 'thf-invisible');
    };
    ThfChartPieComponent.decorators = [
        { type: Component, args: [{
                    selector: 'thf-chart-pie', template: "<div #chartBody class=\"thf-chart-body\"> <div #svgContainer class=\"thf-chart-svg-container\"></div> <div class=\"thf-chart-tooltip thf-tooltip thf-invisible\"> <div class=\"thf-tooltip-arrow thf-arrow-bottom\"></div> <div class=\"thf-tooltip-content\">{{ tooltipText }}</div> </div> </div>"
                },] },
    ];
    /** @nocollapse */
    ThfChartPieComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: Renderer2 }
    ]; };
    return ThfChartPieComponent;
}(ThfChartDynamicTypeComponent));
export { ThfChartPieComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    ThfChartPieComponent.prototype.animationRunning;
    /**
     * @type {?}
     * @private
     */
    ThfChartPieComponent.prototype.chartItemEndAngle;
    /**
     * @type {?}
     * @private
     */
    ThfChartPieComponent.prototype.chartItemStartAngle;
    /**
     * @type {?}
     * @private
     */
    ThfChartPieComponent.prototype.chartItemsEndAngleList;
    /**
     * @type {?}
     * @private
     */
    ThfChartPieComponent.prototype.svgPathElementsList;
    /**
     * @type {?}
     * @private
     */
    ThfChartPieComponent.prototype.el;
    /**
     * @type {?}
     * @private
     */
    ThfChartPieComponent.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    ThfChartPieComponent.prototype.renderer;
}
