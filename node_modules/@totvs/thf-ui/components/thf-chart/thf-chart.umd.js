(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs', '@angular/common'], factory) :
	(factory((global['thf-chart'] = {}),global.core,global.rxjs,global.common));
}(this, (function (exports,core,rxjs,common) { 'use strict';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var ThfChartType = {
    /**
     * **Gráfico pizza:** utilizado para exibir proporções de valores a partir de um todo.
     */
    Pie: 'pie',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfChartComponent
 *
 * \@description
 *
 * Interface que define cada objeto do `ThfPieChartSeries`.
 * @record
 */

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Idiomas suportados pelas páginas
/** @type {?} */

// Idioma padrão
/** @type {?} */

/**
 * Retorna idioma do browser ou o idioma padrão.
 * @return {?}
 */

/**
 * @param {?} val
 * @return {?}
 */

/**
 * @param {?} value
 * @param {?=} valueDefault
 * @return {?}
 */
function convertToInt(value, valueDefault) {
    /** @type {?} */
    var validNumber = parseInt(value, 10);
    /** @type {?} */
    var validDefaultValue = parseInt(valueDefault, 10);
    /** @type {?} */
    var defaultValue = validDefaultValue || validDefaultValue === 0 ? validDefaultValue : undefined;
    return validNumber || validNumber === 0 ? validNumber : defaultValue;
}
/**
 * @param {?} object
 * @param {?} type
 * @return {?}
 */
function isTypeof(object, type) {
    return typeof object === type;
}
/**
 *
 * @param {?} fn Função que será executada dentro do contexto. Podendo ser o nome da função
 * ou a referência da mesma.
 *
 * @param {?} context Contexto do qual a função será executada.
 * @param {?=} param
 * @return {?}
 */

/**
 * @param {?} value
 * @param {?} start
 * @param {?} end
 * @return {?}
 */

/**
 * @param {?} date
 * @return {?}
 */

/**
 * @param {?} date
 * @param {?=} time
 * @return {?}
 */

/**
 * Transforma o ano em uma string no formato yyyy e caso o ano seja menor que 1000 preenche com zeros a esquerda.
 * @param {?} year Ano
 * @return {?}
 */

// Verifica se o navegador em que está sendo usado é Internet Explorer ou Edge
/**
 * @return {?}
 */

// Verifica qual o dispositivo que está sendo usado
/**
 * @return {?}
 */

/**
 * @param {?} value
 * @param {?} comparedValue
 * @return {?}
 */

/**
 * @param {?} event
 * @return {?}
 */

/**
 * Caso o ano original da data seja entre 0 e 100 atribui esse valor ao ano, pois o `new Date` do javascript transforma o ano para 190X.
 * @param {?} date Data
 * @param {?} year Ano original
 * @return {?}
 */

/**
 * @param {?} options
 * @param {?} property
 * @return {?}
 */

/**
 * @param {?} list
 * @return {?}
 */

/**
 * @param {?} list
 * @return {?}
 */

/**
 * @param {?} value
 * @return {?}
 */

/**
 * @param {?} url
 * @return {?}
 */

/**
 * @param {?} url
 * @return {?}
 */

/**
 * @param {?} link
 * @return {?}
 */

/**
 * Método responsável por ordenar dois valores.
 *
 * @param {?} leftSide Primeiro valor a ser comparado.
 * @param {?} rightSide Segundo valor a ser comparado.
 * @param {?=} ascending Determina se será em ordem ascendente ou descendente.
 * @return {?}
 */

/**
 * @param {?} date
 * @param {?} dateStart
 * @param {?} dateEnd
 * @return {?}
 */

/**
 * @return {?}
 */

/**
 * @param {?} text
 * @return {?}
 */

/**
 * Mapeia um novo array apenas com as propriedades definidas pelo desenvolvedor baseado em um array de
 * origem.
 *
 * Exemplo:
 *
 * ```
 * const people = [
 *  { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 },
 *  { id: 2, name: 'Beltrano', birthdate: '1997-01-21', genre: 'Female', city: 'Joinville', dependents: 0 },
 *  { id: 3, name: 'Siclano', birthdate: '1995-07-15', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapArrayByProperties(people, properties);
 *
 * console.log(idAndName); // [{ id: 1, name: 'Fulano' }, { id: 2, name: 'Beltrano' }, { id: 3, name: 'Siclano' }]
 * ```
 *
 * Um outro uso para o método é "parear" todos os objetos do array com as mesmas propriedades.
 *
 * ```
 * const customers = [
 *  { id: 1, name: 'Fulano', city: 'São Paulo', dependents: 2 }, // sem genre
 *  { id: 2, name: 'Beltrano', genre: 'Female', city: 'Joinville' }, // sem dependents
 *  { id: 3, name: 'Siclano', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 * const properties = ['id', 'name', 'city', 'genre', 'dependents'];
 *
 * const pattern = mapArrayByProperties(customers, properties);
 * console.log(pattern);
 *
 * // [
 * //   { id: 1, name: 'Fulano', city: 'São Paulo', genre: undefined, dependents: 2 },
 * //   { id: 2, name: 'Beltrano', city: 'Joinville', genre: 'Female', dependents: undefined },
 * //   { id: 3, name: 'Siclano', city: 'Joinville', genre: 'Male', dependents: 0 }
 * // ]
 * ```
 *
 * @param {?=} items {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */

/**
 * Mapeia um novo objeto apenas com as propriedades definidas pelo desenvolvedor.
 *
 * Exemplo:
 *
 * ```
 * const person = { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 };
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapObjectByProperties(person, properties);
 *
 * console.log(idAndName); // { id: 1, name: 'Fulano' }
 * ```
 *
 * @param {?=} object {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */

/**
 * Retorna os valores de um objeto dentro de um array.
 *
 * > Simula o Object.values(obj), o mesmo deve ser removido assim que a versão typescrit for atualizada.
 *
 * @param {?=} object Objeto de onde será pego os valores.
 * @return {?}
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var thfChartDefaultHeight = 400;
/** @type {?} */
var thfChartTypeDefault = ThfChartType.Pie;
/** @type {?} */
var thfChartMinHeight = 200;
/**
 * \@description
 *
 * O `thf-chart` é um componente para renderização de dados através de gráficos, com isso facilitando a compreensão e tornando a
 * visualização destes dados mais agradável.
 *
 * Este componente também possibilita a definição das seguintes propriedades: altura do gráfico; série(s) que irão compor o gráfico;
 * título do gráfico; e tipo de gráfico.
 *
 * Além das definições de propriedades, também é possível definir uma ação que será executada ao clicar em determinado elemento do gráfico
 * e outra que será executada ao passar o *mouse* sobre o elemento.
 *
 * #### Boas práticas
 *
 * - Para que o gráfico não fique ilegível e incompreensível, evite uma quantia excessiva de séries.
 *
 * @abstract
 */
var ThfChartBaseComponent = /** @class */ (function () {
    function ThfChartBaseComponent() {
        this._height = thfChartDefaultHeight;
        this._type = thfChartTypeDefault;
        this.thfChartType = ThfChartType;
        /**
         * Evento executado quando o usuário clicar sobre um elemento do gráfico.
         *
         * > Será passado por parâmetro um objeto contendo a categoria e valor da série.
         */
        this.seriesClick = new core.EventEmitter();
        /**
         * Evento executado quando o usuário passar o *mouse* sobre um elemento do gráfico.
         *
         * > Será passado por parâmetro um objeto contendo a categoria e valor da série.
         */
        this.seriesHover = new core.EventEmitter();
    }
    Object.defineProperty(ThfChartBaseComponent.prototype, "height", {
        get: /**
         * @return {?}
         */
        function () {
            return this._height;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define a altura do gráfico.
         *
         * > O valor mínimo que pode ser informado é 200.
         *
         * @default `400px`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define a altura do gráfico.
         *
         * > O valor mínimo que pode ser informado é 200.
         *
         * \@default `400px`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var intValue = convertToInt(value);
            /** @type {?} */
            var height;
            if (isTypeof(value, 'number')) {
                height = intValue <= thfChartMinHeight ? thfChartMinHeight : intValue;
            }
            else {
                height = thfChartDefaultHeight;
            }
            this._height = height;
            this.rebuildComponent();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfChartBaseComponent.prototype, "type", {
        // TODO quando houver a necessidade de informar um type.
        // /**
        //  * @optional
        //  *
        //  * @description
        //  *
        //  * Define o tipo de gráfico.
        //  *
        //  * > Veja os valores válidos no *enum* `ThfChartType`.
        //  *
        //  * @default `ThfChartType.Pie`
        //  */
        // @Input('t-type') set type(value: ThfChartType) {
        //   this._type = (<any>Object).values(ThfChartType).includes(value) ? value : thfChartTypeDefault;
        // }
        get: 
        // TODO quando houver a necessidade de informar um type.
        // /**
        //  * @optional
        //  *
        //  * @description
        //  *
        //  * Define o tipo de gráfico.
        //  *
        //  * > Veja os valores válidos no *enum* `ThfChartType`.
        //  *
        //  * @default `ThfChartType.Pie`
        //  */
        // @Input('t-type') set type(value: ThfChartType) {
        //   this._type = (<any>Object).values(ThfChartType).includes(value) ? value : thfChartTypeDefault;
        // }
        /**
         * @return {?}
         */
        function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    ThfChartBaseComponent.prototype.onSeriesClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.seriesClick.emit(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ThfChartBaseComponent.prototype.onSeriesHover = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.seriesHover.emit(event);
    };
    ThfChartBaseComponent.propDecorators = {
        height: [{ type: core.Input, args: ['t-height',] }],
        series: [{ type: core.Input, args: ['t-series',] }],
        title: [{ type: core.Input, args: ['t-title',] }],
        seriesClick: [{ type: core.Output, args: ['t-series-click',] }],
        seriesHover: [{ type: core.Output, args: ['t-series-hover',] }]
    };
    return ThfChartBaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Array de cores para gráficos definido pela equipe de UX Totvs.
/** @type {?} */
var ThfChartColors = [
    ['#29B6C5'],
    ['#0C6C94', '#29B6C5'],
    ['#0C6C94', '#29B6C5', '#C9ECF0'],
    ['#0C6C94', '#0B92B4', '#29B6C5', '#94DAE2'],
    ['#0C6C94', '#0B92B4', '#29B6C5', '#94DAE2', '#C9ECF0'],
    ['#0C6C94', '#00A5C5', '#0082A8', '#31628D', '#364473', '#32285C'],
    ['#0C6C94', '#00AACB', '#018DAE', '#277099', '#325783', '#35426E', '#32285D'],
    ['#0C6C94', '#00AFCE', '#0194B6', '#117FA2', '#0088AC', '#23789F', '#2B6992', '#32285C'],
    ['#0C6C94', '#00BAD5', '#00A7C7', '#0197B8', '#0088AC', '#23789F', '#2B6992', '#315C87', '#32285C'],
    ['#0C6C94', '#00BAD5', '#00A7C7', '#0197B8', '#0088AC', '#23789F', '#2B6992', '#315C87', '#364E7C', '#32285C'],
    ['#0C6C94', '#00BAD5', '#00A7C7', '#0197B8', '#0088AC', '#23789F', '#2B6992', '#315C87', '#364E7C', '#36436F', '#32285C'],
    ['#0C6C94', '#00BAD5', '#00A7C7', '#0197B8', '#0088AC', '#23789F', '#2B6992', '#315C87', '#364E7C', '#36436F', '#333565', '#32285C'],
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var thfChartAnimationDurationTime = 1500;
/** @type {?} */
var thfChartAngleStepInterval = Math.PI * 2 / Math.floor(thfChartAnimationDurationTime / 60);
/** @type {?} */
var thfChartCompleteCircle = 0.0001;
/** @type {?} */
var thfChartPadding = 24;
/** @type {?} */
var thfChartStartAngle = -Math.PI / 2;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var Padding = 24;
/**
 * @abstract
 */
var ThfChartDynamicTypeComponent = /** @class */ (function () {
    function ThfChartDynamicTypeComponent() {
        this.onSerieClick = new rxjs.Subject();
        this.onSerieHover = new rxjs.Subject();
        this.series = [];
    }
    /**
     * @param {?} chartWrapperElement
     * @param {?} chartHeaderElement
     * @param {?} chartLegendElement
     * @return {?}
     */
    ThfChartDynamicTypeComponent.prototype.calculateSVGContainerDimensions = /**
     * @param {?} chartWrapperElement
     * @param {?} chartHeaderElement
     * @param {?} chartLegendElement
     * @return {?}
     */
    function (chartWrapperElement, chartHeaderElement, chartLegendElement) {
        /** @type {?} */
        var svgContainerHeightCalc = this.height - chartHeaderElement - chartLegendElement - (Padding * 2);
        this.svgHeight = svgContainerHeightCalc <= 0 ? 0 : svgContainerHeightCalc;
        this.centerX = chartWrapperElement / 2;
    };
    /**
     * @return {?}
     */
    ThfChartDynamicTypeComponent.prototype.calculateTotalValue = /**
     * @return {?}
     */
    function () {
        this.totalValue = this.series.reduce(function (previousValue, serie) { return previousValue + serie.value; }, 0);
    };
    ThfChartDynamicTypeComponent.propDecorators = {
        chartBody: [{ type: core.ViewChild, args: ['chartBody',] }],
        svgContainer: [{ type: core.ViewChild, args: ['svgContainer',] }]
    };
    return ThfChartDynamicTypeComponent;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ThfChartPieComponent = /** @class */ (function (_super) {
    __extends(ThfChartPieComponent, _super);
    function ThfChartPieComponent(el, ngZone, renderer) {
        var _this = _super.call(this) || this;
        _this.el = el;
        _this.ngZone = ngZone;
        _this.renderer = renderer;
        _this.chartItemsEndAngleList = [];
        _this.svgPathElementsList = [];
        return _this;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} totalValue
     * @return {?}
     */
    ThfChartPieComponent.calculateEndAngle = /**
     * @private
     * @param {?} value
     * @param {?} totalValue
     * @return {?}
     */
    function (value, totalValue) {
        return value / totalValue * (Math.PI * 2);
    };
    /**
     * @return {?}
     */
    ThfChartPieComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeWindowResizeListener();
        this.removeWindowScrollListener();
        this.animationRunning = false;
    };
    /**
     * @return {?}
     */
    ThfChartPieComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.chartInitSetup();
        this.setEventListeners();
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.animationSetup = /**
     * @private
     * @return {?}
     */
    function () {
        this.chartItemStartAngle = thfChartStartAngle;
        this.chartItemEndAngle = this.chartItemsEndAngleList[0];
        this.animationRunning = true;
        this.drawPathInit();
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.calculateAngleRadians = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.series.forEach(function (serie, index) {
            return _this.chartItemsEndAngleList[index] = ThfChartPieComponent.calculateEndAngle(serie.value, _this.totalValue);
        });
    };
    /**
     * @private
     * @param {?} angleCurrentPosition
     * @return {?}
     */
    ThfChartPieComponent.prototype.calculateCurrentEndAngle = /**
     * @private
     * @param {?} angleCurrentPosition
     * @return {?}
     */
    function (angleCurrentPosition) {
        /** @type {?} */
        var isSerieDrawCompleted = this.chartItemStartAngle + angleCurrentPosition > this.chartItemStartAngle + this.chartItemEndAngle;
        if (isSerieDrawCompleted) {
            return (this.chartItemStartAngle + this.chartItemEndAngle) - thfChartCompleteCircle;
        }
        else {
            return this.chartItemStartAngle + angleCurrentPosition;
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfChartPieComponent.prototype.changeTooltipPosition = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.tooltipElement && this.tooltipElement.classList.contains('thf-invisible')) {
            this.showTooltip();
        }
        /** @type {?} */
        var tooltipPositions = this.setTooltipPositions(event);
        this.renderer.setStyle(this.tooltipElement, 'left', tooltipPositions.left + "px");
        this.renderer.setStyle(this.tooltipElement, 'top', tooltipPositions.top + "px");
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.chartInitSetup = /**
     * @private
     * @return {?}
     */
    function () {
        this.calculateSVGContainerDimensions(this.chartWrapper, this.chartHeader, this.chartLegend);
        this.calculateTotalValue();
        this.calculateAngleRadians();
        this.createSVGElements();
        this.animationSetup();
    };
    /**
     * @private
     * @param {?} index
     * @param {?} serie
     * @param {?} svgPathsWrapper
     * @return {?}
     */
    ThfChartPieComponent.prototype.createPath = /**
     * @private
     * @param {?} index
     * @param {?} serie
     * @param {?} svgPathsWrapper
     * @return {?}
     */
    function (index, serie, svgPathsWrapper) {
        /** @type {?} */
        var svgPath = this.renderer.createElement('svg:path', 'svg');
        this.renderer.setAttribute(svgPath, 'class', 'thf-path-item');
        this.renderer.setAttribute(svgPath, 'fill', this.colors[index]);
        this.renderer.setAttribute(svgPath, 'data-tooltip-category', serie.category);
        this.renderer.setAttribute(svgPath, 'data-tooltip-value', serie.value);
        svgPathsWrapper.appendChild(svgPath);
        this.renderer.appendChild(this.svgElement, svgPathsWrapper);
        this.svgPathElementsList.push(svgPath);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.createPaths = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var svgPathsWrapper = this.renderer.createElement('svg:g', 'svg');
        this.series.forEach(function (serie, index) { return _this.createPath(index, serie, svgPathsWrapper); });
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.createSVGElements = /**
     * @private
     * @return {?}
     */
    function () {
        this.svgElement = this.renderer.createElement('svg:svg', 'svg');
        this.renderer.setAttribute(this.svgElement, 'viewBox', "0 0 " + this.chartWrapper + " " + this.centerX * 2);
        this.renderer.setAttribute(this.svgElement, 'preserveAspectRatio', 'xMidYMin meet');
        this.renderer.setAttribute(this.svgElement, 'class', 'thf-chart-svg-element');
        this.renderer.setAttribute(this.svgElement, 'width', "" + (this.chartWrapper - thfChartPadding * 2));
        this.renderer.setAttribute(this.svgElement, 'height', "" + this.svgHeight);
        this.svgContainer.nativeElement.appendChild(this.svgElement);
        this.createPaths();
    };
    /**
     * @private
     * @param {?} path
     * @param {?} chartItemStartAngle
     * @param {?} chartItemEndAngle
     * @return {?}
     */
    ThfChartPieComponent.prototype.drawPath = /**
     * @private
     * @param {?} path
     * @param {?} chartItemStartAngle
     * @param {?} chartItemEndAngle
     * @return {?}
     */
    function (path, chartItemStartAngle, chartItemEndAngle) {
        /** @type {?} */
        var largeArc = (chartItemEndAngle - chartItemStartAngle) % (Math.PI * 2) > Math.PI ? 1 : 0;
        /** @type {?} */
        var startX = this.centerX + Math.cos(chartItemStartAngle) * this.centerX;
        /** @type {?} */
        var startY = this.centerX + Math.sin(chartItemStartAngle) * this.centerX;
        /** @type {?} */
        var endX = this.centerX + Math.cos(chartItemEndAngle) * this.centerX;
        /** @type {?} */
        var endY = this.centerX + Math.sin(chartItemEndAngle) * this.centerX;
        /** @type {?} */
        var pathCoordinates = [
            'M', startX, startY,
            'A', this.centerX, this.centerX, 0, largeArc, 1, endX, endY,
            'L', this.centerX, this.centerX,
            'Z'
        ].join(' ');
        return path.setAttribute('d', pathCoordinates);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.drawPathInit = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.animationRunning) {
            return;
        }
        else {
            this.ngZone.runOutsideAngular(function () { return _this.drawSeries(); });
        }
    };
    /**
     * @private
     * @param {?=} currentSerieIndex
     * @param {?=} angleCurrentPosition
     * @return {?}
     */
    ThfChartPieComponent.prototype.drawSeries = /**
     * @private
     * @param {?=} currentSerieIndex
     * @param {?=} angleCurrentPosition
     * @return {?}
     */
    function (currentSerieIndex, angleCurrentPosition) {
        if (currentSerieIndex === void 0) { currentSerieIndex = 0; }
        if (angleCurrentPosition === void 0) { angleCurrentPosition = 0; }
        /** @type {?} */
        var isFinishedDrawingCurrentSeries = angleCurrentPosition > this.chartItemEndAngle;
        /** @type {?} */
        var isFinishedDrawingAllSeries = currentSerieIndex === this.svgPathElementsList.length;
        if (isFinishedDrawingAllSeries) {
            return;
        }
        if (isFinishedDrawingCurrentSeries) {
            this.chartItemStartAngle = this.chartItemStartAngle + this.chartItemEndAngle;
            currentSerieIndex++;
            this.chartItemEndAngle = this.chartItemsEndAngleList[currentSerieIndex];
            angleCurrentPosition = 0;
        }
        else {
            angleCurrentPosition += thfChartAngleStepInterval;
            this.drawPath(this.svgPathElementsList[currentSerieIndex], this.chartItemStartAngle, this.calculateCurrentEndAngle(angleCurrentPosition));
        }
        window.requestAnimationFrame(this.drawSeries.bind(this, currentSerieIndex, angleCurrentPosition));
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfChartPieComponent.prototype.emitEventOnEnter = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onSerieHover.next(event);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.onMouseClick = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var serieOnClick = { category: this.chartElementCategory, value: this.chartElementValue };
        this.onSerieClick.next(serieOnClick);
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfChartPieComponent.prototype.onMouseEnter = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.tooltipElement = this.chartBody.nativeElement.lastChild;
        this.chartElementCategory = event.target.getAttributeNS(null, 'data-tooltip-category');
        this.chartElementValue = event.target.getAttributeNS(null, 'data-tooltip-value');
        this.tooltipText = this.chartElementCategory + ": " + this.chartElementValue;
        this.showTooltip();
        this.changeTooltipPosition(event);
        /** @type {?} */
        var serieOnEnter = { category: this.chartElementCategory, value: this.chartElementValue };
        this.emitEventOnEnter(serieOnEnter);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.onWindowResize = /**
     * @private
     * @return {?}
     */
    function () {
        this.calculateSVGContainerDimensions(this.chartWrapper, this.chartHeader, this.chartLegend);
        this.renderer.setAttribute(this.svgElement, 'width', "" + (this.chartWrapper - thfChartPadding * 2));
        this.renderer.setAttribute(this.svgElement, 'height', "" + this.svgHeight);
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.removeTooltip = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.tooltipElement) {
            this.renderer.addClass(this.tooltipElement, 'thf-invisible');
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.removeWindowResizeListener = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.windowResizeListener) {
            this.windowResizeListener();
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.removeWindowScrollListener = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.windowScrollListener) {
            this.windowScrollListener();
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.setEventListeners = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var chartSeries = this.el.nativeElement.querySelectorAll('.thf-path-item');
        chartSeries = Array.from(chartSeries);
        chartSeries.forEach(function (serie) {
            _this.renderer.listen(serie, 'click', _this.onMouseClick.bind(_this));
            _this.renderer.listen(serie, 'mouseenter', _this.onMouseEnter.bind(_this));
            _this.renderer.listen(serie, 'mousemove', _this.changeTooltipPosition.bind(_this));
            _this.renderer.listen(serie, 'mouseleave', _this.removeTooltip.bind(_this));
        });
        this.windowResizeListener = this.renderer.listen(window, 'resize', this.onWindowResize.bind(this));
        this.windowScrollListener = this.renderer.listen(this.checkingIfScrollsWithThfPage(), 'scroll', this.removeTooltip.bind(this));
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.checkingIfScrollsWithThfPage = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var thfPageContent = document.getElementsByClassName('thf-page-content');
        return thfPageContent.length ? thfPageContent[0] : window;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfChartPieComponent.prototype.setTooltipPositions = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var displacement = 8;
        return {
            left: event.clientX - this.tooltipElement.offsetWidth / 2,
            top: event.clientY - this.tooltipElement.offsetHeight - displacement
        };
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartPieComponent.prototype.showTooltip = /**
     * @private
     * @return {?}
     */
    function () {
        this.renderer.removeClass(this.tooltipElement, 'thf-invisible');
    };
    ThfChartPieComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-chart-pie', template: "<div #chartBody class=\"thf-chart-body\"> <div #svgContainer class=\"thf-chart-svg-container\"></div> <div class=\"thf-chart-tooltip thf-tooltip thf-invisible\"> <div class=\"thf-tooltip-arrow thf-arrow-bottom\"></div> <div class=\"thf-tooltip-content\">{{ tooltipText }}</div> </div> </div>"
                },] },
    ];
    /** @nocollapse */
    ThfChartPieComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.NgZone },
        { type: core.Renderer2 }
    ]; };
    return ThfChartPieComponent;
}(ThfChartDynamicTypeComponent));

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfChartBaseComponent
 *
 * \@example
 *
 * <example name="thf-chart-basic" title="Totvs Chart Basic">
 *  <file name="sample-thf-chart-basic/sample-thf-chart-basic.component.html"> </file>
 *  <file name="sample-thf-chart-basic/sample-thf-chart-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-chart-labs" title="Totvs Chart Labs">
 *  <file name="sample-thf-chart-labs/sample-thf-chart-labs.component.html"> </file>
 *  <file name="sample-thf-chart-labs/sample-thf-chart-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-chart-coffee-ranking" title="Totvs Chart - Coffee Ranking">
 *  <file name="sample-thf-chart-coffee-ranking/sample-thf-chart-coffee-ranking.component.html"> </file>
 *  <file name="sample-thf-chart-coffee-ranking/sample-thf-chart-coffee-ranking.component.ts"> </file>
 * </example>
 */
var ThfChartComponent = /** @class */ (function (_super) {
    __extends$1(ThfChartComponent, _super);
    function ThfChartComponent(changeDetector, componentFactoryResolver, differs) {
        var _a;
        var _this = _super.call(this) || this;
        _this.changeDetector = changeDetector;
        _this.componentFactoryResolver = componentFactoryResolver;
        _this.differs = differs;
        _this.calculatedElement = false;
        _this.initialized = false;
        _this.windowResizeListener = new rxjs.Subject();
        _this.mappings = (_a = {}, _a[ThfChartType.Pie] = ThfChartPieComponent, _a);
        _this.onResize = function () { return _this.windowResizeListener.next(); };
        _this.differ = _this.differs.find([]).create(null);
        return _this;
    }
    /**
     * @return {?}
     */
    ThfChartComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.initialized = true;
    };
    /**
     * @return {?}
     */
    ThfChartComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var charWrapperWidth = this.chartWrapper.nativeElement.offsetWidth;
        // Permite que o chart seja calculado na primeira vez que o componente torna-se visível,
        // evitando com isso, problemas com Tabs ou Divs que iniciem escondidas.
        if (charWrapperWidth && !this.calculatedElement && this.initialized) {
            this.calculatedElement = true;
            this.getSeriesColor();
            this.dynamicComponentSetting();
        }
        this.checkingForSerieChanges();
    };
    /**
     * @return {?}
     */
    ThfChartComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeWindowResizeListener();
    };
    /**
     * @return {?}
     */
    ThfChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.getSeriesColor();
    };
    /**
     * @return {?}
     */
    ThfChartComponent.prototype.rebuildComponent = /**
     * @return {?}
     */
    function () {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.dynamicComponentSetting();
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartComponent.prototype.checkingForSerieChanges = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.componentRef && this.differ) {
            /** @type {?} */
            var changeSeries = this.differ.diff(this.series);
            if (changeSeries) {
                this.getSeriesColor();
                this.rebuildComponent();
            }
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartComponent.prototype.createComponent = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var componentType = this.getComponentType(this.type);
        /** @type {?} */
        var factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
        this.componentRef = this.chartContainer.createComponent(factory);
        /** @type {?} */
        var instance = (/** @type {?} */ (this.componentRef.instance));
        this.setChartProperties(instance);
        return instance;
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartComponent.prototype.dynamicComponentSetting = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var instance = this.createComponent();
        this.setResizeListenerSubscribe(instance);
        this.changeDetector.detectChanges();
        this.setClickSubscribe(instance);
        this.setHoverSubscribe(instance);
    };
    /**
     * @private
     * @param {?} typeName
     * @return {?}
     */
    ThfChartComponent.prototype.getComponentType = /**
     * @private
     * @param {?} typeName
     * @return {?}
     */
    function (typeName) {
        return this.mappings[typeName];
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartComponent.prototype.getSeriesColor = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var colorsLength = ThfChartColors.length - 1;
        if (!this.series) {
            return this.colors = ThfChartColors[colorsLength];
        }
        /** @type {?} */
        var seriesLength = this.series.length - 1;
        if (seriesLength > colorsLength) {
            /** @type {?} */
            var colors = ThfChartColors[colorsLength];
            // recupera o resultado da divisao entre tamanho das series e o numero de cores disponiveis
            /** @type {?} */
            var quantityDuplicates = seriesLength / colorsLength;
            for (var i = 1; i <= quantityDuplicates; i++) {
                colors = colors.concat(ThfChartColors[colorsLength]);
            }
            return this.colors = colors;
        }
        return this.colors = ThfChartColors[seriesLength];
    };
    /**
     * @private
     * @return {?}
     */
    ThfChartComponent.prototype.removeWindowResizeListener = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.onResize) {
            this.onResize = function () { };
        }
    };
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    ThfChartComponent.prototype.setChartProperties = /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    function (instance) {
        instance.chartHeader = this.chartHeader.nativeElement.offsetHeight;
        instance.chartLegend = this.chartLegend.nativeElement.offsetHeight;
        instance.chartWrapper = this.chartWrapper.nativeElement.offsetWidth;
        instance.colors = this.colors;
        instance.height = this.height;
        instance.series = this.series || [];
    };
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    ThfChartComponent.prototype.setClickSubscribe = /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    function (instance) {
        var _this = this;
        instance.onSerieClick.subscribe(function (event) {
            _this.onSeriesClick(event);
        });
    };
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    ThfChartComponent.prototype.setHoverSubscribe = /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    function (instance) {
        var _this = this;
        instance.onSerieHover.subscribe(function (event) {
            _this.onSeriesHover(event);
        });
    };
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    ThfChartComponent.prototype.setResizeListenerSubscribe = /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    function (instance) {
        var _this = this;
        this.windowResizeListener.subscribe(function () {
            instance.chartHeader = _this.chartHeader.nativeElement.offsetHeight;
            instance.chartLegend = _this.chartLegend.nativeElement.offsetHeight;
            instance.chartWrapper = _this.chartWrapper.nativeElement.offsetWidth;
        });
    };
    ThfChartComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-chart', template: "<div #chartWrapper class=\"thf-chart-wrapper\"> <div #chartHeader class=\"thf-chart-header\"> <div class=\"thf-chart-title\">{{ title }}</div> </div> <ng-template #chartContainer></ng-template> <div #chartLegend class=\"thf-chart-legend\"> <div class=\"thf-chart-legend-container\"> <div class=\"thf-chart-legend-item\" *ngFor=\"let serie of series; let i = index\"> <div class=\"thf-chart-legend-square\" [style.background]=\"colors[i]\"></div> <span class=\"thf-chart-legend-text\">{{ serie.category }}</span> </div> </div> </div> </div> "
                },] },
    ];
    /** @nocollapse */
    ThfChartComponent.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef },
        { type: core.ComponentFactoryResolver },
        { type: core.IterableDiffers }
    ]; };
    ThfChartComponent.propDecorators = {
        chartContainer: [{ type: core.ViewChild, args: ['chartContainer', { read: core.ViewContainerRef },] }],
        chartHeader: [{ type: core.ViewChild, args: ['chartHeader',] }],
        chartLegend: [{ type: core.ViewChild, args: ['chartLegend',] }],
        chartWrapper: [{ type: core.ViewChild, args: ['chartWrapper',] }],
        onResize: [{ type: core.HostListener, args: ['window:resize', ['$event'],] }]
    };
    return ThfChartComponent;
}(ThfChartBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente `thf-chart`.
 */
var ThfChartModule = /** @class */ (function () {
    function ThfChartModule() {
    }
    ThfChartModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                    ],
                    declarations: [
                        ThfChartComponent,
                        ThfChartPieComponent,
                    ],
                    entryComponents: [
                        ThfChartPieComponent
                    ],
                    exports: [
                        ThfChartComponent,
                    ]
                },] },
    ];
    return ThfChartModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

exports.ThfChartType = ThfChartType;
exports.ThfChartComponent = ThfChartComponent;
exports.ThfChartModule = ThfChartModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));
