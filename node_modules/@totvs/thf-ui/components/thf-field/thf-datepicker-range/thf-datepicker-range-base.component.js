var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { EventEmitter, Input, Output } from '@angular/core';
import { browserLanguage, convertToBoolean, thfLocaleDefault } from './../../../utils/util';
import { requiredFailed } from '../validators';
/** @type {?} */
export var thfDatepickerRangeLiteralsDefault = {
    en: (/** @type {?} */ ({
        invalidFormat: 'Date in invalid format',
        startDateGreaterThanEndDate: 'Start date greater than end date',
    })),
    es: (/** @type {?} */ ({
        invalidFormat: 'Fecha en formato no válido',
        startDateGreaterThanEndDate: 'Fecha de inicio mayor que fecha final',
    })),
    pt: (/** @type {?} */ ({
        invalidFormat: 'Data no formato inválido',
        startDateGreaterThanEndDate: 'Data inicial maior que data final',
    }))
};
/**
 * \@description
 *
 * O `thf-datepicker-range` é um componente para seleção de um período entre duas datas, onde é possível informar apenas
 * a data inicial ou a data final.
 *
 * O componente `[(ngModel)]` do `thf-datepicker-range` trabalha com um objeto que implementa a interface
 * `ThfDatepickerRange`, contendo as seguintes propriedades:
 * ```
 * { "start": '2017-11-28', "end": '2017-11-30' }
 * ```
 *
 * <a id="accepted-formats"></a>
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * new Date(2017, 10, 28);
 * ```
 *
 * > O componente respeitará o formato passado para o *model* via codificação. Porém, caso seja feita alteração em algum
 * dos valores de data em tela, o componente atribuirá o formato **Data (E8601DAw.): yyyy-mm-dd** ao model.
 *
 * Importante:
 *
 * - Quando preenchidas a data inicial e final, a data inicial deve ser sempre menor ou igual a data final;
 * - Ao passar uma data inválida via codificação, o valor será mantido no *model* e o `input` da tela aparecerá vazio;
 * - Permite trabalhar com as duas datas separadamente através das propriedades `t-start-date` e `t-end-date` no lugar do
 * `[(ngModel)]`, no entanto sem a validação do formulário;
 * - Para a validação do formulário, utilize o `[(ngModel)]`.
 * @abstract
 */
var ThfDatepickerRangeBaseComponent = /** @class */ (function () {
    function ThfDatepickerRangeBaseComponent(thfDateService) {
        this.thfDateService = thfDateService;
        this.errorMessage = '';
        this._clean = false;
        this._readonly = false;
        this._required = false;
        this.dateRange = { start: '', end: '' };
        this.format = 'dd/mm/yyyy';
        this.isDateRangeInputFormatValid = true;
        this.isStartDateRangeInputValid = true;
        /**
         * \@optional
         *
         * \@description
         *
         * Evento disparado ao alterar valor do campo.
         */
        this.onChange = new EventEmitter();
    }
    Object.defineProperty(ThfDatepickerRangeBaseComponent.prototype, "isDateRangeInputValid", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerRangeBaseComponent.prototype, "clean", {
        get: /**
         * @return {?}
         */
        function () {
            return this._clean;
        },
        /**
         * @optional
         *
         * @description
         *
         * Habilita ação para limpar o campo.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Habilita ação para limpar o campo.
         *
         * \@default `false`
         * @param {?} clean
         * @return {?}
         */
        function (clean) {
            this._clean = convertToBoolean(clean);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerRangeBaseComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        /**
         * @optional
         *
         * @description
         *
         * Desabilita o campo.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Desabilita o campo.
         *
         * \@default `false`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = convertToBoolean(value);
            this.validateModel(this.dateRange);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerRangeBaseComponent.prototype, "endDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._endDate;
        },
        /**
         * @optional
         *
         * @description
         *
         * Data final.
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Data final.
         * @param {?} date
         * @return {?}
         */
        function (date) {
            this._endDate = this.convertPatternDateFormat(date);
            this.dateRange.end = this.endDate;
            this.updateScreenByModel(this.dateRange);
            this.updateModel(this.dateRange);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerRangeBaseComponent.prototype, "literals", {
        get: /**
         * @return {?}
         */
        function () {
            return this._literals || thfDatepickerRangeLiteralsDefault[browserLanguage()];
        },
        /**
         * @optional
         *
         * @description
         *
         * Objeto com as literais usadas no `thf-datepicker-range`.
         *
         * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
         *
         * ```
         *  const customLiterals: ThfDatepickerRangeLiterals = {
         *    invalidFormat: 'Date in inconsistent format',
         *    startDateGreaterThanEndDate: 'End date less than start date'
         *  };
         * ```
         *
         * Ou passando apenas as literais que deseja customizar:
         *
         * ```
         *  const customLiterals: ThfDatepickerRangeLiterals = {
         *    invalidFormat: 'Date in inconsistent format'
         *  };
         * ```
         *
         * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
         *
         * ```
         * <thf-datepicker-range
         *   [t-literals]="customLiterals">
         * </thf-datepicker-range>
         * ```
         *
         * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Objeto com as literais usadas no `thf-datepicker-range`.
         *
         * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
         *
         * ```
         *  const customLiterals: ThfDatepickerRangeLiterals = {
         *    invalidFormat: 'Date in inconsistent format',
         *    startDateGreaterThanEndDate: 'End date less than start date'
         *  };
         * ```
         *
         * Ou passando apenas as literais que deseja customizar:
         *
         * ```
         *  const customLiterals: ThfDatepickerRangeLiterals = {
         *    invalidFormat: 'Date in inconsistent format'
         *  };
         * ```
         *
         * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
         *
         * ```
         * <thf-datepicker-range
         *   [t-literals]="customLiterals">
         * </thf-datepicker-range>
         * ```
         *
         * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value instanceof Object && !(value instanceof Array)) {
                this._literals = __assign({}, thfDatepickerRangeLiteralsDefault[thfLocaleDefault], thfDatepickerRangeLiteralsDefault[browserLanguage()], value);
            }
            else {
                this._literals = thfDatepickerRangeLiteralsDefault[browserLanguage()];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerRangeBaseComponent.prototype, "readonly", {
        get: /**
         * @return {?}
         */
        function () {
            return this._readonly;
        },
        /**
         * @optional
         *
         * @description
         *
         * Indica que o campo será somente leitura.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Indica que o campo será somente leitura.
         *
         * \@default `false`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._readonly = convertToBoolean(value);
            this.validateModel(this.dateRange);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerRangeBaseComponent.prototype, "required", {
        get: /**
         * @return {?}
         */
        function () {
            return this._required;
        },
        /**
         * @optional
         *
         * @description
         *
         * Indica que o campo será obrigatório.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Indica que o campo será obrigatório.
         *
         * \@default `false`
         * @param {?} required
         * @return {?}
         */
        function (required) {
            this._required = convertToBoolean(required);
            this.validateModel(this.dateRange);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerRangeBaseComponent.prototype, "startDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._startDate;
        },
        /**
         * @optional
         *
         * @description
         *
         * Data inicial.
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Data inicial.
         * @param {?} date
         * @return {?}
         */
        function (date) {
            this._startDate = this.convertPatternDateFormat(date);
            this.dateRange.start = this.startDate;
            this.updateScreenByModel(this.dateRange);
            this.updateModel(this.dateRange);
        },
        enumerable: true,
        configurable: true
    });
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.registerOnChange = 
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    function (func) {
        this.onChangeModel = func;
    };
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.registerOnTouched = 
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    function (func) {
        this.onTouchedModel = func;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.validatorChange = fn;
    };
    /**
     * @param {?} control
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.validate = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var value = control.value || {};
        /** @type {?} */
        var startDate = value.start ? this.convertPatternDateFormat(value.start) : '';
        /** @type {?} */
        var endDate = value.end ? this.convertPatternDateFormat(value.end) : '';
        if (this.requiredDateRangeFailed(startDate, endDate)) {
            this.errorMessage = '';
            return { required: {
                    valid: false,
                } };
        }
        if (this.dateRangeObjectFailed(control.value) || this.dateRangeFormatFailed(startDate, endDate)) {
            this.errorMessage = this.literals.invalidFormat;
            return { date: {
                    valid: false,
                } };
        }
        if (this.dateRangeFailed(startDate, endDate)) {
            this.errorMessage = this.literals.startDateGreaterThanEndDate;
            return { date: {
                    valid: false,
                } };
        }
        return null;
    };
    /**
     * @param {?} dateRange
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.writeValue = /**
     * @param {?} dateRange
     * @return {?}
     */
    function (dateRange) {
        this.resetDateRangeInputValidation();
        if (!dateRange || this.dateRangeObjectFailed(dateRange)) {
            this.dateRange = { start: '', end: '' };
        }
        if (!dateRange) {
            this.validateModel(this.dateRange);
        }
        if (this.dateRangeObjectFailed(dateRange)) {
            this.updateModel(dateRange);
        }
        if (this.isDateRangeObject(dateRange)) {
            this.dateRange = {
                start: this.convertPatternDateFormat(dateRange.start),
                end: this.convertPatternDateFormat(dateRange.end)
            };
            this.updateModel(this.dateRange);
        }
        this.updateScreenByModel(this.dateRange);
    };
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.dateFormatFailed = /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value && !this.thfDateService.isValidIso(value);
    };
    // Executa a função onChange
    // Executa a função onChange
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.updateModel = 
    // Executa a função onChange
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var model = typeof (value) === 'object' ? __assign({}, value) : value;
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangeModel) {
            this.onChangeModel(model);
        }
    };
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.validateModel = /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var model = __assign({}, value);
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.convertPatternDateFormat = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value instanceof Date) {
            return this.thfDateService.convertDateToISO(value);
        }
        return value;
    };
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.dateRangeFailed = /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    function (startDate, endDate) {
        return !this.thfDateService.isDateRangeValid(endDate, startDate) || !this.isStartDateRangeInputValid;
    };
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.dateRangeFormatFailed = /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    function (startDate, endDate) {
        return this.dateFormatFailed(endDate) || this.dateFormatFailed(startDate) || !this.isDateRangeInputFormatValid;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.dateRangeObjectFailed = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value && !this.isDateRangeObject(value);
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.isDateRangeObject = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value && value.hasOwnProperty('start') && value.hasOwnProperty('end');
    };
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.requiredDateRangeFailed = /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    function (startDate, endDate) {
        return this.isDateRangeInputValid &&
            requiredFailed(this.required, this.disabled, startDate) &&
            requiredFailed(this.required, this.disabled, endDate);
    };
    ThfDatepickerRangeBaseComponent.propDecorators = {
        clean: [{ type: Input, args: ['t-clean',] }],
        disabled: [{ type: Input, args: ['t-disabled',] }],
        endDate: [{ type: Input, args: ['t-end-date',] }],
        help: [{ type: Input, args: ['t-help',] }],
        label: [{ type: Input, args: ['t-label',] }],
        literals: [{ type: Input, args: ['t-literals',] }],
        readonly: [{ type: Input, args: ['t-readonly',] }],
        required: [{ type: Input, args: ['t-required',] }],
        startDate: [{ type: Input, args: ['t-start-date',] }],
        onChange: [{ type: Output, args: ['t-change',] }]
    };
    return ThfDatepickerRangeBaseComponent;
}());
export { ThfDatepickerRangeBaseComponent };
if (false) {
    /** @type {?} */
    ThfDatepickerRangeBaseComponent.prototype.errorMessage;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._clean;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._endDate;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._literals;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._readonly;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._required;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype._startDate;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype.onChangeModel;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerRangeBaseComponent.prototype.validatorChange;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.dateRange;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.format;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.isDateRangeInputFormatValid;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.isStartDateRangeInputValid;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.onTouchedModel;
    /**
     * \@optional
     *
     * \@description
     *
     * Texto de apoio do campo.
     * @type {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.help;
    /**
     * \@optional
     *
     * \@description
     *
     * Rótulo do campo.
     * @type {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.label;
    /**
     * \@optional
     *
     * \@description
     *
     * Evento disparado ao alterar valor do campo.
     * @type {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.onChange;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerRangeBaseComponent.prototype.thfDateService;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.resetDateRangeInputValidation = function () { };
    /**
     * @abstract
     * @protected
     * @param {?} dateRange
     * @return {?}
     */
    ThfDatepickerRangeBaseComponent.prototype.updateScreenByModel = function (dateRange) { };
}
