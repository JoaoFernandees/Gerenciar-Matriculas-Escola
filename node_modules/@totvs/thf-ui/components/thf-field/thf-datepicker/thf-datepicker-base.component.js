/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { EventEmitter, Input, Output } from '@angular/core';
import { convertDateToISODate, convertDateToISOExtended, convertIsoToDate, convertToBoolean, formatYear, isTypeof, setYearFrom0To100, validateDateRange } from '../../../utils/util';
import { dateFailed, requiredFailed } from './../validators';
import { ThfMask } from '../thf-input/thf-mask';
/** @type {?} */
var thfDatepickerFormatDefault = 'dd/mm/yyyy';
/**
 * \@description
 *
 * O `thf-datepicker` é um componente específico para manipulação de datas permitindo a digitação e / ou seleção.
 *
 * O formato de exibição da data, ou seja, o formato que é apresentado ao usuário é o dd/mm/yyyy,
 * mas podem ser definidos outros padrões (veja mais na propriedade `t-format`).
 *
 * O idioma padrão do calendário será exibido de acordo com o navegador, caso tenha necessidade de alterar
 * use a propriedade `t-locale`.
 *
 * O datepicker aceita três formatos de data: o E8601DZw (yyyy-mm-ddThh:mm:ss+|-hh:mm), o E8601DAw (yyyy-mm-dd) e o
 * Date padrão do Javascript.
 *
 * > O formato de saída do *model* se ajusta conforme o formato de entrada, veja abaixo:
 *
 * - Formato de entrada e saída (E8601DZw) - `'2017-11-28T00:00:00-02:00'`;
 *
 * - Formato de entrada e saída (E8601DAw) - `'2017-11-28'`;
 *
 * - Formato de entrada (Date) - `new Date(2017, 10, 28)` e saída (E8601DZw) - `'2017-11-28T00:00:00-02:00'`;
 *
 * **Importante:**
 *
 * - Para utilizar datas com ano inferior a 100, verificar o comportamento do [`new Date`](https://www.w3schools.com/js/js_dates.asp)
 * e utilizar o método [`setFullYear`](https://www.w3schools.com/jsref/jsref_setfullyear.asp).
 * - Caso a data esteja inválida, o `model` receberá **'Data inválida'**.
 * - Caso o `input` esteja passando um `[(ngModel)]`, mas não tenha um `name`, então irá ocorrer um erro
 * do próprio Angular (`[ngModelOptions]="{standalone: true}"`).
 *
 * Exemplo:
 *
 * ```
 * <thf-datepicker
 *   [(ngModel)]="pessoa.nome"
 *   [ngModelOptions]="{standalone: true}"
 * </thf-datepicker>
 * ```
 *
 * > Não esqueça de importar o `FormsModule` em seu módulo, tal como para utilizar o `input default`.
 * @abstract
 */
var ThfDatepickerBaseComponent = /** @class */ (function () {
    function ThfDatepickerBaseComponent() {
        this._format = thfDatepickerFormatDefault;
        this._placeholder = '';
        this.firstStart = true;
        this.hour = 'T00:00:01-00:00';
        this.isExtendedISO = true;
        this.onChangeModel = null;
        this.onTouchedModel = null;
        /**
         * Desabilita o campo.
         */
        this.disabled = false;
        /**
         * Torna o elemento somente leitura.
         */
        this.readonly = false;
        /**
         * Faz com que o campo seja obrigatório.
         */
        this.required = false;
        /**
         * Aplica foco ao elemento ao ser iniciado.
         */
        this.focus = false;
        /**
         * Habilita ação para limpar o campo.
         */
        this.clean = false;
        /**
         * Mensagem apresentada quando a data for inválida ou fora do período.
         *
         * > Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja obrigatório.
         */
        this.errorPattern = '';
        /**
         * Evento disparado ao sair do campo.
         */
        this.onblur = new EventEmitter();
        /**
         * Evento disparado ao alterar valor do campo.
         */
        this.onchange = new EventEmitter();
    }
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "placeholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this._placeholder;
        },
        /**
         * @optional
         *
         * @description
         *
         * Mensagem que aparecerá enquanto o campo não estiver preenchido.
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Mensagem que aparecerá enquanto o campo não estiver preenchido.
         * @param {?} placeholder
         * @return {?}
         */
        function (placeholder) {
            this._placeholder = isTypeof(placeholder, 'string') ? placeholder : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setDisabled", {
        set: /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this.disabled = disabled === '' ? true : convertToBoolean(disabled);
            this.validateModel(convertDateToISOExtended(this.date, this.hour));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setReadonly", {
        set: /**
         * @param {?} readonly
         * @return {?}
         */
        function (readonly) {
            this.readonly = readonly === '' ? true : convertToBoolean(readonly);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setRequired", {
        set: /**
         * @param {?} required
         * @return {?}
         */
        function (required) {
            this.required = required === '' ? true : convertToBoolean(required);
            this.validateModel(convertDateToISOExtended(this.date, this.hour));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setFocus", {
        set: /**
         * @param {?} focus
         * @return {?}
         */
        function (focus) {
            this.focus = focus === '' ? true : convertToBoolean(focus);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setClean", {
        set: /**
         * @param {?} clean
         * @return {?}
         */
        function (clean) {
            this.clean = clean === '' ? true : convertToBoolean(clean);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setDateStart", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value instanceof Date) {
                /** @type {?} */
                var year = value.getFullYear();
                /** @type {?} */
                var date = new Date(year, value.getMonth(), value.getDate(), 0, 0, 0);
                setYearFrom0To100(date, year);
                this.start = date;
            }
            else {
                this.start = convertIsoToDate(value, true, false);
            }
            this.validateModel(convertDateToISOExtended(this.date, this.hour));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setDateEnd", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value instanceof Date) {
                /** @type {?} */
                var year = value.getFullYear();
                /** @type {?} */
                var date = new Date(year, value.getMonth(), value.getDate(), 23, 59, 59);
                setYearFrom0To100(date, year);
                this.end = date;
            }
            else {
                this.end = convertIsoToDate(value, false, true);
            }
            this.validateModel(convertDateToISOExtended(this.date, this.hour));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "format", {
        get: /**
         * @return {?}
         */
        function () {
            return this._format;
        },
        /**
         * @optional
         *
         * @description
         *
         * Formato de exibição da data.
         *
         * Valores válidos:
         *  - `dd/mm/yyyy`
         *  - `mm/dd/yyyy`
         *  - `yyyy/mm/dd`
         *
         * @default `dd/mm/yyyy`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Formato de exibição da data.
         *
         * Valores válidos:
         *  - `dd/mm/yyyy`
         *  - `mm/dd/yyyy`
         *  - `yyyy/mm/dd`
         *
         * \@default `dd/mm/yyyy`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                value = value.toLowerCase();
                if (value.match(/dd/) && value.match(/mm/) && value.match(/yyyy/)) {
                    this._format = value;
                    this.objMask = this.buildMask();
                    this.refreshValue(this.date);
                    return;
                }
            }
            this._format = thfDatepickerFormatDefault;
            this.objMask = this.buildMask();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "locale", {
        get: /**
         * @return {?}
         */
        function () {
            return this._locale || navigator.language;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this._locale = value.length >= 2 ? value : 'pt';
            }
            else {
                this._locale = navigator.language;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // Classe de máscara
        this.objMask = this.buildMask();
    };
    // Converte um objeto string em Date
    // Converte um objeto string em Date
    /**
     * @param {?} dateString
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.getDateFromString = 
    // Converte um objeto string em Date
    /**
     * @param {?} dateString
     * @return {?}
     */
    function (dateString) {
        /** @type {?} */
        var day = parseInt(dateString.substring(this.format.indexOf('d'), this.format.indexOf('d') + 2), 10);
        /** @type {?} */
        var month = parseInt(dateString.substring(this.format.indexOf('m'), this.format.indexOf('m') + 2), 10) - 1;
        /** @type {?} */
        var year = parseInt(dateString.substring(this.format.indexOf('y'), this.format.indexOf('y') + 4), 10);
        /** @type {?} */
        var date = new Date(year, month, day);
        setYearFrom0To100(date, year);
        return (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) ? date : null;
    };
    // Formata a data.
    // Formata a data.
    /**
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.formatToDate = 
    // Formata a data.
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var dateFormatted = this.format;
        dateFormatted = dateFormatted.replace('dd', ('0' + value.getDate()).slice(-2));
        dateFormatted = dateFormatted.replace('mm', ('0' + (value.getMonth() + 1)).slice(-2));
        dateFormatted = dateFormatted.replace('yyyy', formatYear(value.getFullYear()));
        return dateFormatted;
    };
    // Método responsável por controlar o modelo.
    // Método responsável por controlar o modelo.
    /**
     * @param {?} date
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.controlModel = 
    // Método responsável por controlar o modelo.
    /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        this.date = date;
        if (date && this.isExtendedISO) {
            this.callOnChange(convertDateToISOExtended(this.date, this.hour));
        }
        else if (date && !this.isExtendedISO) {
            this.callOnChange(convertDateToISODate(this.date));
        }
        else {
            date === undefined ? this.callOnChange('') : this.callOnChange('Data inválida');
        }
    };
    // Executa a função onChange
    // Executa a função onChange
    /**
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.callOnChange = 
    // Executa a função onChange
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangeModel) {
            this.onChangeModel(value);
        }
    };
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.registerOnChange = 
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    function (func) {
        this.onChangeModel = func;
    };
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.registerOnTouched = 
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    function (func) {
        this.onTouchedModel = func;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.validatorChange = fn;
    };
    /**
     * @protected
     * @param {?} model
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.validateModel = /**
     * @protected
     * @param {?} model
     * @return {?}
     */
    function (model) {
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    };
    // Retorna um objeto do tipo ThfMask com a mascara configurada.
    // Retorna um objeto do tipo ThfMask com a mascara configurada.
    /**
     * @protected
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.buildMask = 
    // Retorna um objeto do tipo ThfMask com a mascara configurada.
    /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var mask = this.format.toUpperCase();
        mask = mask.replace(/DD/g, '99');
        mask = mask.replace(/MM/g, '99');
        mask = mask.replace(/YYYY/g, '9999');
        return new ThfMask(mask, true);
    };
    /**
     * @param {?} c
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        // Verifica se já possui algum error pattern padrão.
        this.errorPattern = this.errorPattern !== 'Data inválida' && this.errorPattern !== 'Data fora do período' ? this.errorPattern : '';
        if (dateFailed(c.value)) {
            this.errorPattern = this.errorPattern || 'Data inválida';
            return { date: {
                    valid: false,
                } };
        }
        if (requiredFailed(this.required, this.disabled, c.value)) {
            return { required: {
                    valid: false,
                } };
        }
        if ((this.date && !validateDateRange(this.date, this.start, this.end))) {
            this.errorPattern = this.errorPattern || 'Data fora do período';
            return { date: {
                    valid: false,
                } };
        }
        return null;
    };
    ThfDatepickerBaseComponent.propDecorators = {
        name: [{ type: Input, args: ['name',] }],
        placeholder: [{ type: Input, args: ['t-placeholder',] }],
        setDisabled: [{ type: Input, args: ['t-disabled',] }],
        setReadonly: [{ type: Input, args: ['t-readonly',] }],
        setRequired: [{ type: Input, args: ['t-required',] }],
        setFocus: [{ type: Input, args: ['t-focus',] }],
        setClean: [{ type: Input, args: ['t-clean',] }],
        errorPattern: [{ type: Input, args: ['t-error-pattern',] }],
        setDateStart: [{ type: Input, args: ['t-start',] }],
        setDateEnd: [{ type: Input, args: ['t-end',] }],
        format: [{ type: Input, args: ['t-format',] }],
        locale: [{ type: Input, args: ['t-locale',] }],
        onblur: [{ type: Output, args: ['t-blur',] }],
        onchange: [{ type: Output, args: ['t-change',] }]
    };
    return ThfDatepickerBaseComponent;
}());
export { ThfDatepickerBaseComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerBaseComponent.prototype._format;
    /**
     * @type {?}
     * @private
     */
    ThfDatepickerBaseComponent.prototype._placeholder;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.date;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.firstStart;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.hour;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.isExtendedISO;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.objMask;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.onChangeModel;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.onTouchedModel;
    /**
     * @type {?}
     * @protected
     */
    ThfDatepickerBaseComponent.prototype.validatorChange;
    /** @type {?} */
    ThfDatepickerBaseComponent.prototype.name;
    /**
     * Desabilita o campo.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.disabled;
    /**
     * Torna o elemento somente leitura.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.readonly;
    /**
     * Faz com que o campo seja obrigatório.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.required;
    /**
     * Aplica foco ao elemento ao ser iniciado.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.focus;
    /**
     * Habilita ação para limpar o campo.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.clean;
    /**
     * Mensagem apresentada quando a data for inválida ou fora do período.
     *
     * > Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja obrigatório.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.errorPattern;
    /**
     * Atribui uma data mínima.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.start;
    /**
     * Atribui uma data máxima.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.end;
    /**
     * \@optional
     *
     * \@description
     *
     * Idioma do Datepicker.
     *
     * Valores válidos:
     *  - `pt`
     *  - `en`
     *  - `es`
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype._locale;
    /**
     * Evento disparado ao sair do campo.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.onblur;
    /**
     * Evento disparado ao alterar valor do campo.
     * @type {?}
     */
    ThfDatepickerBaseComponent.prototype.onchange;
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.writeValue = function (value) { };
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.refreshValue = function (value) { };
}
