/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Para usar o thf-mask é preciso instanciar esta classe passando a máscara como
 * primeiro parâmetro, e no segundo parâmetro, deve se informado true, caso queira
 * que o model seja formatado ou false para o que o model seja limpo.
 */
var /**
 * Para usar o thf-mask é preciso instanciar esta classe passando a máscara como
 * primeiro parâmetro, e no segundo parâmetro, deve se informado true, caso queira
 * que o model seja formatado ou false para o que o model seja limpo.
 */
ThfMask = /** @class */ (function () {
    function ThfMask(mask, formatModel) {
        this.mask = '';
        this.formatModel = false;
        // controle de posição
        this.initialPosition = 0;
        this.finalPosition = 0;
        this.pattern = '';
        this.mask = mask;
        this.formatModel = formatModel;
        this.pattern = this.getRegexFromMask(mask);
    }
    Object.defineProperty(ThfMask.prototype, "getPattern", {
        get: /**
         * @return {?}
         */
        function () {
            return this.pattern;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfMask.prototype, "getValueToInput", {
        get: /**
         * @return {?}
         */
        function () {
            return this.valueToInput;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfMask.prototype, "setValueToInput", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.valueToInput = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfMask.prototype, "getValueToModel", {
        get: /**
         * @return {?}
         */
        function () {
            return this.valueToModel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfMask.prototype, "setValueToModel", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.valueToModel = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.keyup = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (this.mask) {
            /** @type {?} */
            var value = $event.target.value;
            // formata o valor quando for colado com control + v e reposiciona o cursor
            if ($event.keyCode === 17 || $event.keyCode === 91) {
                $event.target.value = this.controlFormatting(value);
                this.resetPositions($event);
            }
            $event.preventDefault();
            switch ($event.keyCode) {
                case 37: // seta esquerda
                    if (this.initialPosition > 0) {
                        this.initialPosition--;
                    }
                    this.setPositionNotShiftKey($event);
                    this.setSelectionRange($event);
                    break;
                case 39: // seta direita
                    if (this.initialPosition < value.toString().length) {
                        this.initialPosition++;
                    }
                    this.setPositionNotShiftKey($event);
                    this.setSelectionRange($event);
                    break;
                case 35: // end
                    this.finalPosition = value.toString().length;
                    if ($event.shiftKey) {
                        this.setPositions($event);
                    }
                    else {
                        this.initialPosition = this.finalPosition;
                        this.setPositions($event);
                    }
                    break;
                case 36: // HOME
                    if ($event.shiftKey) {
                        this.finalPosition = this.initialPosition;
                        this.initialPosition = 0;
                        this.setPositions($event);
                    }
                    else {
                        this.initialPosition = 0;
                        this.finalPosition = 0;
                        this.setPositions($event);
                    }
                    break;
            }
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.setPositionNotShiftKey = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (!$event.shiftKey) {
            this.finalPosition = this.initialPosition;
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.setSelectionRange = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (this.initialPosition > this.finalPosition) {
            $event.target.setSelectionRange(this.finalPosition, this.initialPosition);
        }
        else {
            $event.target.setSelectionRange(this.initialPosition, this.finalPosition);
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.keydown = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (this.mask) {
            /** @type {?} */
            var value = $event.target.value;
            if ($event.keyCode === 9) {
                return;
            }
            if (!$event.ctrlKey && !$event.metaKey) {
                $event.preventDefault();
            }
            // Não faz nada quando for digitado CTRL ou COMMAND e V
            // Já está sendo tratado no evento keyup
            if ($event.ctrlKey || $event.metaKey && ($event.keyCode !== 86) ||
                ($event.keyCode >= 37 && $event.keyCode <= 40) || $event.keyCode === 16 || $event.keyCode === 9) {
                return;
            }
            // Valida a tecla digitada
            if (this.isKeyValid($event.keyCode)) {
                if (this.finalPosition === null) {
                    this.finalPosition = this.initialPosition;
                }
                this.revertPositions(this.initialPosition, this.finalPosition);
                switch ($event.keyCode) {
                    case 8: // backspace
                        this.getPosition($event);
                        if (this.initialPosition < 0) {
                            this.initialPosition = 0;
                            this.setPositions($event);
                        }
                        if (this.initialPosition === this.finalPosition) {
                            this.checkMaskBefore($event, -1);
                            if (this.initialPosition !== 0) {
                                value = value.slice(0, this.initialPosition - 1) + value.slice(this.finalPosition);
                                value = this.controlFormatting(value);
                                $event.target.value = value;
                                this.changePosition($event, -1);
                                this.checkMaskBefore($event, -1);
                                this.setPositions($event);
                                this.resetPositions($event);
                            }
                        }
                        else {
                            this.clearRangeSelection(value, $event, true);
                        }
                        this.setPositions($event);
                        break;
                    case 46: // delete
                        this.getPosition($event);
                        if (this.initialPosition === this.finalPosition) {
                            this.checkMaskAfter($event, 1);
                            value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition + 1);
                            value = this.controlFormatting(value);
                            $event.target.value = value;
                            this.setPositions($event);
                            this.resetPositions($event);
                        }
                        else {
                            this.clearRangeSelection(value, $event, false);
                        }
                        this.setPositions($event);
                        break;
                    default: // qualquer outra tecla válida
                        value = value.slice(0, this.initialPosition) + $event.key + value.slice(this.finalPosition);
                        value = this.controlFormatting(value);
                        $event.target.value = value;
                        this.changePosition($event, 1);
                        this.checkMaskBefore($event, 1);
                        this.setPositions($event);
                        this.resetPositions($event);
                        this.setPositions($event);
                }
            }
        }
    };
    /**
     * @param {?} value
     * @param {?} $event
     * @param {?} isBackspace
     * @return {?}
     */
    ThfMask.prototype.clearRangeSelection = /**
     * @param {?} value
     * @param {?} $event
     * @param {?} isBackspace
     * @return {?}
     */
    function (value, $event, isBackspace) {
        value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition);
        value = this.controlFormatting(value);
        $event.target.value = value;
        if (isBackspace) {
            this.checkMaskBefore($event, -1);
        }
        this.setPositions($event);
        this.resetPositions($event);
    };
    // passa a posição do click para o controle de posição
    // passa a posição do click para o controle de posição
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.click = 
    // passa a posição do click para o controle de posição
    /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.initialPosition = $event.target.selectionStart;
        this.finalPosition = $event.target.selectionEnd;
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.blur = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        // Se houver algum valor definido na máscara
        if (this.mask) {
            // pega o valor do campo, formata e passa para o model
            /** @type {?} */
            var value = $event.target.value;
            value = this.controlFormatting(value);
            $event.target.value = value;
        }
    };
    /**
     * @param {?} initialPosition
     * @param {?} finalPosition
     * @return {?}
     */
    ThfMask.prototype.revertPositions = /**
     * @param {?} initialPosition
     * @param {?} finalPosition
     * @return {?}
     */
    function (initialPosition, finalPosition) {
        if (initialPosition > finalPosition) {
            // inverte o controle de posição caso o inicial esteja maior que o final
            /** @type {?} */
            var tempPosition = void 0;
            tempPosition = initialPosition;
            this.initialPosition = finalPosition;
            this.finalPosition = tempPosition;
        }
    };
    // reseta o controle de posição
    // reseta o controle de posição
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.resetPositions = 
    // reseta o controle de posição
    /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.initialPosition = $event.target.selectionStart;
        this.finalPosition = this.initialPosition;
    };
    // posiciona o cursor de acordo com o controle de posição
    // posiciona o cursor de acordo com o controle de posição
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.setPositions = 
    // posiciona o cursor de acordo com o controle de posição
    /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        $event.target.setSelectionRange(this.initialPosition, this.finalPosition);
    };
    // muda a posição do cursor e atualiza o controle de posição
    // muda a posição do cursor e atualiza o controle de posição
    /**
     * @param {?} $event
     * @param {?} value
     * @return {?}
     */
    ThfMask.prototype.changePosition = 
    // muda a posição do cursor e atualiza o controle de posição
    /**
     * @param {?} $event
     * @param {?} value
     * @return {?}
     */
    function ($event, value) {
        this.initialPosition = this.initialPosition + value;
        this.finalPosition = this.finalPosition + value;
        this.setPositions($event);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.getPosition = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.initialPosition = $event.target.selectionStart;
        this.finalPosition = $event.target.selectionEnd;
        this.setPositions($event);
    };
    // Método responsável por controlar a formatação e aplicar todas as máscara possíveis
    // quando houver valores opcionais (?)
    // Método responsável por controlar a formatação e aplicar todas as máscara possíveis
    // quando houver valores opcionais (?)
    /**
     * @param {?} value
     * @return {?}
     */
    ThfMask.prototype.controlFormatting = 
    // Método responsável por controlar a formatação e aplicar todas as máscara possíveis
    // quando houver valores opcionais (?)
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // Se o valor for vazio, retorna vazio
        if (!value) {
            this.valueToInput = '';
            this.valueToModel = '';
            return '';
        }
        /** @type {?} */
        var valueProcessed;
        /** @type {?} */
        var maskTmp = this.mask;
        // Array que será usado para armazenar todas as máscaras possíveis para
        // quando houver um valor opcional (?)
        /** @type {?} */
        var arrMasks = [];
        /** @type {?} */
        var contMasks = 0;
        // Enquanto houver algum 9? na máscara
        while (this.hasOptionalNumber(maskTmp)) {
            arrMasks.push(maskTmp);
            maskTmp = this.replaceOptionalNumber(maskTmp);
        }
        arrMasks.push(maskTmp);
        // Inverte o array
        arrMasks.reverse();
        // Informa que a formatação ainda não chegou ao fim
        this.formattingEnds = false;
        while (!this.formattingEnds) {
            // Seta a formatação como terminada
            // Então o método formatValue irá setar como não terminado caso haja
            this.formattingEnds = true;
            // Se não existe mais nenhuma máscara possível, então encerra a formatação
            if (!arrMasks[contMasks]) {
                break;
            }
            // Chama a formatação passando a máscara e o valor
            valueProcessed = this.formatValue(value, arrMasks[contMasks]);
            contMasks++;
        }
        return valueProcessed;
    };
    // Função que formata a máscara com o valor passado
    // Função que formata a máscara com o valor passado
    /**
     * @param {?} value
     * @param {?} mask
     * @return {?}
     */
    ThfMask.prototype.formatValue = 
    // Função que formata a máscara com o valor passado
    /**
     * @param {?} value
     * @param {?} mask
     * @return {?}
     */
    function (value, mask) {
        // Remove as marcas de valor opciona (?)
        mask = mask.replace(/\?/g, '');
        // Substitui todos os caracteres que não são fixos da máscara por _
        /** @type {?} */
        var guide = mask.replace(this.listValidKeys(), '_');
        // Contador usado para percorrer o guide
        /** @type {?} */
        var contGuide = 0;
        // String final formatada
        /** @type {?} */
        var valueProcessed = '';
        // Remove do valor todos os caracteres fixos como ()/-+
        value = this.removeFormattingValue(value);
        // Percorre todo o valor e coloca a formatação de acordo com a máscara
        for (var i = 0; i < value.length; i++) {
            /** @type {?} */
            var charValue = value[i];
            // Se o guide acabou, seta a formatação como não terminada para que o método controlFormatting
            // tente formatar com outra possível máscara
            if (!guide[contGuide]) {
                this.formattingEnds = false;
                break;
            }
            // Percorre o Guide enquanto tem caracteres fixos
            while (this.isFixedCharacterGuide(guide[contGuide]) && guide[contGuide]) {
                valueProcessed += guide[contGuide];
                contGuide++;
            }
            // É um caracter válido de acordo com a máscara
            if (this.isKeyValidMask(charValue, mask[contGuide])) {
                valueProcessed += charValue;
                contGuide++;
            }
            else {
                // Se não é um caracter válido, deve interromper.
                break;
            }
        }
        if (this.formatModel) {
            this.valueToInput = valueProcessed;
            this.valueToModel = valueProcessed;
        }
        else {
            this.valueToInput = valueProcessed;
            this.valueToModel = this.removeFormattingValue(valueProcessed);
        }
        return valueProcessed;
    };
    // verifica se tem algum caracter de mascara antes do cursor
    // verifica se tem algum caracter de mascara antes do cursor
    /**
     * @param {?} $event
     * @param {?} position
     * @return {?}
     */
    ThfMask.prototype.checkMaskBefore = 
    // verifica se tem algum caracter de mascara antes do cursor
    /**
     * @param {?} $event
     * @param {?} position
     * @return {?}
     */
    function ($event, position) {
        if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition - 1))) {
            this.changePosition($event, position);
            this.checkMaskBefore($event, position);
        }
    };
    // verifica se tem algum caracter de mascara depois do cursor
    // verifica se tem algum caracter de mascara depois do cursor
    /**
     * @param {?} $event
     * @param {?} position
     * @return {?}
     */
    ThfMask.prototype.checkMaskAfter = 
    // verifica se tem algum caracter de mascara depois do cursor
    /**
     * @param {?} $event
     * @param {?} position
     * @return {?}
     */
    function ($event, position) {
        if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition))) {
            this.changePosition($event, position);
            this.checkMaskAfter($event, position);
        }
    };
    // Retorna a máscara sem um valor opcional
    // Retorna a máscara sem um valor opcional
    /**
     * @param {?} mask
     * @return {?}
     */
    ThfMask.prototype.replaceOptionalNumber = 
    // Retorna a máscara sem um valor opcional
    /**
     * @param {?} mask
     * @return {?}
     */
    function (mask) {
        /** @type {?} */
        var i = 9;
        while (i >= 0) {
            if (mask.indexOf(i + '?') > -1) {
                return mask.replace(i + '?', '');
            }
            i--;
        }
        return mask;
    };
    // Verifica se contém caracteres permitidos somente na máscara \/() +-
    // Verifica se contém caracteres permitidos somente na máscara \/() +-
    /**
     * @param {?} key
     * @return {?}
     */
    ThfMask.prototype.isFixedCharacterGuide = 
    // Verifica se contém caracteres permitidos somente na máscara \/() +-
    /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.testRegex(key, this.getFixedCharacterGuide());
    };
    // Retorna caracteres permitidos somente na máscara \/() +-
    // Retorna caracteres permitidos somente na máscara \/() +-
    /**
     * @return {?}
     */
    ThfMask.prototype.getFixedCharacterGuide = 
    // Retorna caracteres permitidos somente na máscara \/() +-
    /**
     * @return {?}
     */
    function () {
        return /[\\\/() +-.\:]/g;
    };
    // Caracteres permitidos de serem digitados
    // Caracteres permitidos de serem digitados
    /**
     * @return {?}
     */
    ThfMask.prototype.listValidKeys = 
    // Caracteres permitidos de serem digitados
    /**
     * @return {?}
     */
    function () {
        return /[a-zA-Z0-9]/g;
    };
    // Se é um dígito válido
    // Se é um dígito válido
    /**
     * @param {?} keyCode
     * @return {?}
     */
    ThfMask.prototype.isKeyValid = 
    // Se é um dígito válido
    /**
     * @param {?} keyCode
     * @return {?}
     */
    function (keyCode) {
        return this.isKeyCodeValid(keyCode);
    };
    // Verifica se a tecla digitada é permitida
    // Permite apenas números, letras, backspace e del
    // Verifica se a tecla digitada é permitida
    // Permite apenas números, letras, backspace e del
    /**
     * @param {?} keyCode
     * @return {?}
     */
    ThfMask.prototype.isKeyCodeValid = 
    // Verifica se a tecla digitada é permitida
    // Permite apenas números, letras, backspace e del
    /**
     * @param {?} keyCode
     * @return {?}
     */
    function (keyCode) {
        return ((keyCode >= 48 && keyCode <= 57) ||
            (keyCode >= 65 && keyCode <= 90) ||
            (keyCode >= 96 && keyCode <= 105) ||
            (keyCode === 8) || keyCode === 9 ||
            (keyCode === 46));
    };
    // Se está de acordo com a máscara
    // Se está de acordo com a máscara
    /**
     * @param {?} key
     * @param {?} keyMask
     * @return {?}
     */
    ThfMask.prototype.isKeyValidMask = 
    // Se está de acordo com a máscara
    /**
     * @param {?} key
     * @param {?} keyMask
     * @return {?}
     */
    function (key, keyMask) {
        return this.testRegex(key, this.replaceMask(keyMask));
    };
    // Retorna se a chave foi aprovada pela expressão regular
    // Retorna se a chave foi aprovada pela expressão regular
    /**
     * @param {?} key
     * @param {?} regex
     * @return {?}
     */
    ThfMask.prototype.testRegex = 
    // Retorna se a chave foi aprovada pela expressão regular
    /**
     * @param {?} key
     * @param {?} regex
     * @return {?}
     */
    function (key, regex) {
        return regex.test(key);
    };
    // Remove a formatacão do valor
    // É possível ser melhorado para remover pontualmente os caracteres fixos de acordo com a máscara
    // Remove a formatacão do valor
    // É possível ser melhorado para remover pontualmente os caracteres fixos de acordo com a máscara
    /**
     * @param {?} value
     * @return {?}
     */
    ThfMask.prototype.removeFormattingValue = 
    // Remove a formatacão do valor
    // É possível ser melhorado para remover pontualmente os caracteres fixos de acordo com a máscara
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value.replace(this.getFixedCharacterGuide(), '');
    };
    // Verifica se contém valor opcional na máscara 0-9?
    // Verifica se contém valor opcional na máscara 0-9?
    /**
     * @param {?} mask
     * @return {?}
     */
    ThfMask.prototype.hasOptionalNumber = 
    // Verifica se contém valor opcional na máscara 0-9?
    /**
     * @param {?} mask
     * @return {?}
     */
    function (mask) {
        return mask.match(/\d\?/g);
    };
    // Retorna a expressão regular correspondente ao comando passado
    // Retorna a expressão regular correspondente ao comando passado
    /**
     * @param {?} char
     * @return {?}
     */
    ThfMask.prototype.replaceMask = 
    // Retorna a expressão regular correspondente ao comando passado
    /**
     * @param {?} char
     * @return {?}
     */
    function (char) {
        /** @type {?} */
        var regex = /./;
        switch (char) {
            case '0':
                regex = /[0]/;
                break;
            case '1':
                regex = /[0-1]/;
                break;
            case '2':
                regex = /[0-2]/;
                break;
            case '3':
                regex = /[0-3]/;
                break;
            case '4':
                regex = /[0-4]/;
                break;
            case '5':
                regex = /[0-5]/;
                break;
            case '6':
                regex = /[0-6]/;
                break;
            case '7':
                regex = /[0-7]/;
                break;
            case '8':
                regex = /[0-8]/;
                break;
            case '9':
                regex = /[0-9]/;
                break;
            case ' ':
                regex = /\s/;
                break;
            case '@':
                regex = /[a-zA-Z]/;
                break;
            case 'w':
                regex = /[a-zA-Z0-9]/;
                break;
        }
        return regex;
    };
    /**
     * @param {?} mask
     * @return {?}
     */
    ThfMask.prototype.getRegexFromMask = /**
     * @param {?} mask
     * @return {?}
     */
    function (mask) {
        if (mask) {
            /** @type {?} */
            var pattern = void 0;
            if (this.formatModel) {
                pattern = mask.replace(/\\/g, '\\\\');
                pattern = pattern.replace(/\+/g, '\\+');
                pattern = pattern.replace(/\./g, '\\.');
                pattern = pattern.replace(/-/g, '-');
                pattern = pattern.replace(/\(/g, '\\(');
                pattern = pattern.replace(/\)/g, '\\)');
                pattern = pattern.replace(/\//g, '\\/');
                pattern = pattern.replace(/\s/g, '\\s');
                pattern = pattern.replace(/:/g, '\\:');
                pattern = pattern.replace(/\@(?!\s)/g, '\\w');
                pattern = pattern.replace(/\d/g, '\\w');
            }
            else {
                pattern = mask.replace(/\\/g, '');
                pattern = pattern.replace(/\+/g, '');
                pattern = pattern.replace(/\./g, '');
                pattern = pattern.replace(/-/g, '');
                pattern = pattern.replace(/\(/g, '');
                pattern = pattern.replace(/\)/g, '');
                pattern = pattern.replace(/\//g, '');
                pattern = pattern.replace(/\s/g, '');
                pattern = pattern.replace(/:/g, '');
                pattern = pattern.replace(/\@/g, '\\w');
                pattern = pattern.replace(/\d/g, '\\w');
            }
            return pattern;
        }
        else {
            return null;
        }
    };
    return ThfMask;
}());
/**
 * Para usar o thf-mask é preciso instanciar esta classe passando a máscara como
 * primeiro parâmetro, e no segundo parâmetro, deve se informado true, caso queira
 * que o model seja formatado ou false para o que o model seja limpo.
 */
export { ThfMask };
if (false) {
    /** @type {?} */
    ThfMask.prototype.mask;
    /** @type {?} */
    ThfMask.prototype.formatModel;
    /** @type {?} */
    ThfMask.prototype.initialPosition;
    /** @type {?} */
    ThfMask.prototype.finalPosition;
    /** @type {?} */
    ThfMask.prototype.pattern;
    /** @type {?} */
    ThfMask.prototype.valueToInput;
    /** @type {?} */
    ThfMask.prototype.valueToModel;
    /** @type {?} */
    ThfMask.prototype.formattingEnds;
}
