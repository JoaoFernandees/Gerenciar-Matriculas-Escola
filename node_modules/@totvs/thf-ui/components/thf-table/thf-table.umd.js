(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/router'), require('uuid')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common', '@angular/router', 'uuid'], factory) :
	(factory((global['thf-table'] = {}),global.core,global.common,global.router,global.uuid));
}(this, (function (exports,core,common,router,uuid) { 'use strict';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@docsExtends ThfPopupAction
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Interface que define as colunas booleanas do `thf-table`.
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Interface para configuração das colunas do `thf-table`.
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Interface para definição das literais usadas no `thf-table`.
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Interface que define as colunas de ícones do `thf-table`.
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Interface para configuração das colunas de labels do `thf-table`.
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Interface para configuração das colunas do `thf-table-detail`.
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Interface para configuração do _detail_ do componente `thf-table`.
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Esta diretiva permite que seja apresentada informações adicionais a respeito de uma determinada linha de
 * dados, de forma que possam ser exibidas e ocultadas através do botão de acionamento.
 *
 * > Quando utilizada, sobrepõe as funcionalidade básicas do *master-detail*.
 *
 * Em seu uso, deve-se utilizar como parâmetro a referência da _linha_ e/ou _índice_, sendo por padrão linha. Caso não seja declarado,
 * o componente não exibirá conteúdo.
 *  - Linha: `row` determina o item da linha corrente.
 *  - Índice: `rowIndex` determina o índice da linha corrente.
 *
 * Esta diretiva compõe-se de dois meios para uso, de forma explícita tal como em *syntax sugar*. Veja a seguir ambos, respectivamente:
 *
 * ```
 * ...
 * <thf-table
 *   [t-columns]="columns"
 *   [t-items]="items">
 *     <ng-template t-table-row-template let-rowItem let-i="rowIndex" [t-table-row-template-show]="isShow">
 *       <detail-row [row]="rowItem"></detail-row>
 *     </ng-template>
 * ...
 * ```
 *
 * ```
 * ...
 * <thf-table
 *   [t-columns]="columns"
 *   [t-items]="items">
 *     <div *t-table-row-template="let rowItem, let i=rowIndex">
 *       <detail-row [row]="rowItem"></detail-row>
 *     </div>
 * ...
 *
 * ```
 *
 * A diretiva **t-table-row-template**, possibilita também que determinada linha apresente ou não seu _template_. Para isto,
 * é necessário atribuir a referência da função que faz esta verificação, à propriedade `t-table-row-template-show`,
 * a mesma deve retornar um valor do tipo *boolean*. Veja o exemplo a seguir:
 *
 * ```
 * ...
 * \@Component({
 *    selector: 'app-root',
 *    templateUrl: `
 *      ...
 *      <thf-table
 *        [t-columns]="columns"
 *        [t-items]="items">
 *          <ng-template t-table-row-template let-rowItem let-i="rowIndex" [t-table-row-template-show]="isUndelivered">
 *            <detail-row [row]="rowItem"> </detail-row>
 *          </div>
 *      ...
 *    `
 * })
 * export class AppComponent {
 *    public dataTable = [{
 *      code: 1200,
 *      product: 'Rice',
 *      costumer: 'Supermarket 1',
 *      quantity: 3,
 *      status: 'delivered',
 *      license_plate: 'MDJD9191',
 *      batch_product: 18041822,
 *      driver: 'José Oliveira'
 *    }, {
 *      code: 1355,
 *      product: 'Bean',
 *      costumer: 'Supermarket 2',
 *      quantity: 1,
 *      status: 'transport',
 *      license_plate: 'XXA5454',
 *      batch_product: 18041821,
 *      driver: 'Francisco Pereira'
 *    }];
 *
 *    isUndelivered(row, index: number) {
 *      return row.status !== 'delivered';
 *    }
 * }
 * ```
 * > No exemplo acima, somente será disponibilizado os detalhes de informações nas linhas cujo o valor de `status`
 * não correspondam à *delivered*.
 */
var ThfTableRowTemplateDirective = /** @class */ (function () {
    // Necessário manter templateRef para o funcionamento do row template.
    function ThfTableRowTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    ThfTableRowTemplateDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[t-table-row-template]'
                },] },
    ];
    /** @nocollapse */
    ThfTableRowTemplateDirective.ctorParameters = function () { return [
        { type: core.TemplateRef }
    ]; };
    ThfTableRowTemplateDirective.propDecorators = {
        thfTableRowTemplateShow: [{ type: core.Input, args: ['t-table-row-template-show',] }]
    };
    return ThfTableRowTemplateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@usedBy ThfTableComponent
 *
 * \@description
 *
 * Interface para configuração das colunas de legenda do Thf-Table.
 * @record
 */

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Idiomas suportados pelas páginas
/** @type {?} */
var thfLocales = ['pt', 'en', 'es'];
// Idioma padrão
/** @type {?} */
var thfLocaleDefault = 'pt';
/**
 * Retorna idioma do browser ou o idioma padrão.
 * @return {?}
 */
function browserLanguage() {
    /** @type {?} */
    var language = navigator.language.toLowerCase().substring(0, 2);
    if (!thfLocales.includes(language)) {
        return thfLocaleDefault;
    }
    return language;
}
/**
 * @param {?} val
 * @return {?}
 */
function convertToBoolean(val) {
    if (typeof val === 'string') {
        val = val.toLowerCase().trim();
        return (val === 'true' || val === 'on' || val === '');
    }
    if (typeof val === 'number') {
        return val === 1;
    }
    return !!val;
}
/**
 * @param {?} value
 * @param {?=} valueDefault
 * @return {?}
 */
function convertToInt(value, valueDefault) {
    /** @type {?} */
    var validNumber = parseInt(value, 10);
    /** @type {?} */
    var validDefaultValue = parseInt(valueDefault, 10);
    /** @type {?} */
    var defaultValue = validDefaultValue || validDefaultValue === 0 ? validDefaultValue : undefined;
    return validNumber || validNumber === 0 ? validNumber : defaultValue;
}
/**
 * @param {?} object
 * @param {?} type
 * @return {?}
 */
function isTypeof(object, type) {
    return typeof object === type;
}
/**
 *
 * @param {?} fn Função que será executada dentro do contexto. Podendo ser o nome da função
 * ou a referência da mesma.
 *
 * @param {?} context Contexto do qual a função será executada.
 * @param {?=} param
 * @return {?}
 */
function callFunction(fn, context, param) {
    if (isTypeof(fn, 'function')) {
        fn.call(context, param);
    }
    else {
        context[fn](param);
    }
}
/**
 * @param {?} value
 * @param {?} start
 * @param {?} end
 * @return {?}
 */

/**
 * @param {?} date
 * @return {?}
 */

/**
 * @param {?} date
 * @param {?=} time
 * @return {?}
 */

/**
 * Transforma o ano em uma string no formato yyyy e caso o ano seja menor que 1000 preenche com zeros a esquerda.
 * @param {?} year Ano
 * @return {?}
 */

// Verifica se o navegador em que está sendo usado é Internet Explorer ou Edge
/**
 * @return {?}
 */

// Verifica qual o dispositivo que está sendo usado
/**
 * @return {?}
 */

/**
 * @param {?} value
 * @param {?} comparedValue
 * @return {?}
 */

/**
 * @param {?} event
 * @return {?}
 */

/**
 * Caso o ano original da data seja entre 0 e 100 atribui esse valor ao ano, pois o `new Date` do javascript transforma o ano para 190X.
 * @param {?} date Data
 * @param {?} year Ano original
 * @return {?}
 */

/**
 * @param {?} options
 * @param {?} property
 * @return {?}
 */

/**
 * @param {?} list
 * @return {?}
 */

/**
 * @param {?} list
 * @return {?}
 */

/**
 * @param {?} value
 * @return {?}
 */

/**
 * @param {?} url
 * @return {?}
 */
function isExternalLink(url) {
    return url ? url.startsWith('http') : false;
}
/**
 * @param {?} url
 * @return {?}
 */
function openExternalLink(url) {
    window.open(url, '_blank');
}
/**
 * @param {?} link
 * @return {?}
 */

/**
 * Método responsável por ordenar dois valores.
 *
 * @param {?} leftSide Primeiro valor a ser comparado.
 * @param {?} rightSide Segundo valor a ser comparado.
 * @param {?=} ascending Determina se será em ordem ascendente ou descendente.
 * @return {?}
 */
function sortValues(leftSide, rightSide, ascending) {
    if (ascending === void 0) { ascending = true; }
    if (ascending) {
        if (leftSide < rightSide) {
            return -1;
        }
        else if (leftSide > rightSide) {
            return 1;
        }
    }
    else if (ascending === false) {
        if (leftSide < rightSide) {
            return 1;
        }
        else if (leftSide > rightSide) {
            return -1;
        }
    }
    return 0;
}
/**
 * @param {?} date
 * @param {?} dateStart
 * @param {?} dateEnd
 * @return {?}
 */

/**
 * @return {?}
 */

/**
 * @param {?} text
 * @return {?}
 */
function capitalizeFirstLetter(text) {
    return "" + text.charAt(0).toUpperCase() + text.slice(1);
}
/**
 * Mapeia um novo array apenas com as propriedades definidas pelo desenvolvedor baseado em um array de
 * origem.
 *
 * Exemplo:
 *
 * ```
 * const people = [
 *  { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 },
 *  { id: 2, name: 'Beltrano', birthdate: '1997-01-21', genre: 'Female', city: 'Joinville', dependents: 0 },
 *  { id: 3, name: 'Siclano', birthdate: '1995-07-15', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapArrayByProperties(people, properties);
 *
 * console.log(idAndName); // [{ id: 1, name: 'Fulano' }, { id: 2, name: 'Beltrano' }, { id: 3, name: 'Siclano' }]
 * ```
 *
 * Um outro uso para o método é "parear" todos os objetos do array com as mesmas propriedades.
 *
 * ```
 * const customers = [
 *  { id: 1, name: 'Fulano', city: 'São Paulo', dependents: 2 }, // sem genre
 *  { id: 2, name: 'Beltrano', genre: 'Female', city: 'Joinville' }, // sem dependents
 *  { id: 3, name: 'Siclano', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 * const properties = ['id', 'name', 'city', 'genre', 'dependents'];
 *
 * const pattern = mapArrayByProperties(customers, properties);
 * console.log(pattern);
 *
 * // [
 * //   { id: 1, name: 'Fulano', city: 'São Paulo', genre: undefined, dependents: 2 },
 * //   { id: 2, name: 'Beltrano', city: 'Joinville', genre: 'Female', dependents: undefined },
 * //   { id: 3, name: 'Siclano', city: 'Joinville', genre: 'Male', dependents: 0 }
 * // ]
 * ```
 *
 * @param {?=} items {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */

/**
 * Mapeia um novo objeto apenas com as propriedades definidas pelo desenvolvedor.
 *
 * Exemplo:
 *
 * ```
 * const person = { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 };
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapObjectByProperties(person, properties);
 *
 * console.log(idAndName); // { id: 1, name: 'Fulano' }
 * ```
 *
 * @param {?=} object {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */

/**
 * Retorna os valores de um objeto dentro de um array.
 *
 * > Simula o Object.values(obj), o mesmo deve ser removido assim que a versão typescrit for atualizada.
 *
 * @param {?=} object Objeto de onde será pego os valores.
 * @return {?}
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço responsável por gerenciar o tratamento dos formatos de data e hora.
 */
var ThfDateService = /** @class */ (function () {
    function ThfDateService() {
        this.dateRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])$');
        this.isoRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])' +
            'T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|' +
            '-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])' +
            '(?:|:?[0-5]\\d)$');
    }
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param minDate Definir `true` caso seja `minDate`.
     * @param maxDate Definir `true` caso seja `maxDate`.
     */
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param {?} dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} minDate Definir `true` caso seja `minDate`.
     * @param {?} maxDate Definir `true` caso seja `maxDate`.
     * @return {?}
     */
    ThfDateService.prototype.convertIsoToDate = /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param {?} dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} minDate Definir `true` caso seja `minDate`.
     * @param {?} maxDate Definir `true` caso seja `maxDate`.
     * @return {?}
     */
    function (dateString, minDate, maxDate) {
        if (dateString) {
            var _a = this.getDateFromIso(dateString), year = _a.year, month = _a.month, day = _a.day;
            if (minDate) {
                /** @type {?} */
                var date = new Date(year, month - 1, day, 0, 0, 0);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else if (maxDate) {
                /** @type {?} */
                var date = new Date(year, month - 1, day, 23, 59, 59);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else {
                /** @type {?} */
                var miliseconds = Date.parse(dateString);
                /** @type {?} */
                var timezone = new Date().getTimezoneOffset() * 60000;
                return new Date(miliseconds + timezone);
            }
        }
    };
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param date Data no formato `Date`.
     */
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param {?} date Data no formato `Date`.
     * @return {?}
     */
    ThfDateService.prototype.convertDateToISO = /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param {?} date Data no formato `Date`.
     * @return {?}
     */
    function (date) {
        if (date) {
            /** @type {?} */
            var fullYear = date.getFullYear();
            /** @type {?} */
            var getMonth = date.getMonth() + 1;
            /** @type {?} */
            var day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
            /** @type {?} */
            var month = getMonth < 10 ? '0' + getMonth : getMonth;
            /** @type {?} */
            var year = this.formatYear(fullYear);
            return year + '-' + month + '-' + day;
        }
        else {
            return null;
        }
    };
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param year Ano a ser validado.
     */
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param {?} year Ano a ser validado.
     * @return {?}
     */
    ThfDateService.prototype.formatYear = /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param {?} year Ano a ser validado.
     * @return {?}
     */
    function (year) {
        if (year > 999) {
            return year.toString();
        }
        if (year > 99 && year < 1000) {
            return "0" + year;
        }
        if (year > 9 && year < 100) {
            return "00" + year;
        }
        if (year >= 0 && year < 10) {
            return "000" + year;
        }
    };
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param isoDate Ano em formato string.
     */
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param {?} isoDate Ano em formato string.
     * @return {?}
     */
    ThfDateService.prototype.getDateFromIso = /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param {?} isoDate Ano em formato string.
     * @return {?}
     */
    function (isoDate) {
        /** @type {?} */
        var day = parseInt(isoDate.substring(8, 10), 10);
        /** @type {?} */
        var month = parseInt(isoDate.substring(5, 7), 10);
        /** @type {?} */
        var year = parseInt(isoDate.substring(0, 4), 10);
        return { year: year, month: month, day: day };
    };
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     */
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param {?} date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     * @return {?}
     */
    ThfDateService.prototype.getDateForDateRange = /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param {?} date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     * @return {?}
     */
    function (date, isMinDate) {
        /** @type {?} */
        var lastHour = isMinDate ? [0, 0, 0] : [23, 59, 59];
        if (date instanceof Date) {
            var _a = this.splitDate(date), year = _a.year, month = _a.month, day = _a.day;
            /** @type {?} */
            var validDate = new (Date.bind.apply(Date, [void 0, year, month, day].concat(lastHour)))();
            this.setYearFrom0To100(validDate, year);
            return validDate;
        }
        else if (this.isValidIso(date)) {
            return this.convertIsoToDate(date, isMinDate, !isMinDate);
        }
    };
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param dateA primeira data
     * @param dateB segunda data
     */
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param {?=} dateA primeira data
     * @param {?=} dateB segunda data
     * @return {?}
     */
    ThfDateService.prototype.isDateRangeValid = /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param {?=} dateA primeira data
     * @param {?=} dateB segunda data
     * @return {?}
     */
    function (dateA, dateB) {
        if (dateA === void 0) { dateA = ''; }
        if (dateB === void 0) { dateB = ''; }
        /** @type {?} */
        var dateASplitted = dateA.split('-').map(function (item) { return parseInt(item, 10); });
        /** @type {?} */
        var dateBSplitted = dateB.split('-').map(function (item) { return parseInt(item, 10); });
        for (var index = 0; index <= dateASplitted.length; index++) {
            if (dateASplitted[index] > dateBSplitted[index]) {
                return true;
            }
            else if (dateASplitted[index] < dateBSplitted[index]) {
                return false;
            }
        }
        return true;
    };
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param stringDate Data.
     */
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param {?} stringDate Data.
     * @return {?}
     */
    ThfDateService.prototype.isValidIso = /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param {?} stringDate Data.
     * @return {?}
     */
    function (stringDate) {
        return this.dateRegex.test(stringDate) || this.isoRegex.test(stringDate);
    };
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param date Data.
     * @param year .
     */
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param {?} date Data.
     * @param {?} year .
     * @return {?}
     */
    ThfDateService.prototype.setYearFrom0To100 = /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param {?} date Data.
     * @param {?} year .
     * @return {?}
     */
    function (date, year) {
        if (year >= 0 && year < 100) {
            date.setFullYear(year);
        }
    };
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param leftSide Primeira data a ser comparada.
     * @param rightSide Segunda data a ser comparada.
     * @param ascending Determina se será em ordem crescente ou decrescente.
     */
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param {?} leftSide Primeira data a ser comparada.
     * @param {?} rightSide Segunda data a ser comparada.
     * @param {?} ascending Determina se será em ordem crescente ou decrescente.
     * @return {?}
     */
    ThfDateService.prototype.sortDate = /**
     * Método responsável por ordenar duas datas.
     *
     * @param {?} leftSide Primeira data a ser comparada.
     * @param {?} rightSide Segunda data a ser comparada.
     * @param {?} ascending Determina se será em ordem crescente ou decrescente.
     * @return {?}
     */
    function (leftSide, rightSide, ascending) {
        return sortValues(this.validateDate(leftSide), this.validateDate(rightSide), ascending);
    };
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param date Valor da data.
     */
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param {?} date Valor da data.
     * @return {?}
     */
    ThfDateService.prototype.splitDate = /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param {?} date Valor da data.
     * @return {?}
     */
    function (date) {
        /** @type {?} */
        var year = date.getFullYear();
        /** @type {?} */
        var month = date.getMonth();
        /** @type {?} */
        var day = date.getDate();
        return { year: year, month: month, day: day };
    };
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param date Data a ser validada.
     * @param minDate Data inicial.
     * @param maxDate Data final.
     */
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param {?} date Data a ser validada.
     * @param {?} minDate Data inicial.
     * @param {?} maxDate Data final.
     * @return {?}
     */
    ThfDateService.prototype.validateDateRange = /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param {?} date Data a ser validada.
     * @param {?} minDate Data inicial.
     * @param {?} maxDate Data final.
     * @return {?}
     */
    function (date, minDate, maxDate) {
        if (minDate && maxDate) {
            return (date >= minDate && date <= maxDate);
        }
        else if (minDate && !maxDate) {
            return (date >= minDate);
        }
        else if (!minDate && maxDate) {
            return (date <= maxDate);
        }
        else {
            return true;
        }
    };
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @param date Data que será validada.
     */
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @private
     * @param {?} date Data que será validada.
     * @return {?}
     */
    ThfDateService.prototype.validateDate = /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @private
     * @param {?} date Data que será validada.
     * @return {?}
     */
    function (date) {
        /** @type {?} */
        var validDate = date instanceof Date ? this.convertDateToISO(date) : date;
        return this.isValidIso(validDate) ? validDate : undefined;
    };
    ThfDateService.decorators = [
        { type: core.Injectable },
    ];
    return ThfDateService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 * \@description
 *
 * Serviço responsável por gerenciar as posições de um elemento em relação a um elemento alvo. Ele pode receber as
 * seguintes posições:
 *
 * - `right`: Posiciona o elemento no lado direito do componente alvo.
 * - `right-bottom`: Posiciona o elemento no lado direito inferior do componente alvo.
 * - `right-top`: Posiciona o elemento no lado direito superior do componente alvo.
 * - `bottom`: Posiciona o elemento abaixo do componente alvo.
 * - `bottom-left`: Posiciona o elemento abaixo e à esquerda do componente alvo.
 * - `bottom-right`: Posiciona o elemento abaixo e à direita do componente alvo.
 * - `left`: Posiciona o elemento no lado esquerdo do componente alvo.
 * - `left-top`: Posiciona o elemento no lado esquerdo superior do componente alvo.
 * - `left-bottom`: Posiciona o elemento no lado esquerdo inferior do componente alvo.
 * - `top`: Posiciona o elemento acima do componente alvo.
 * - `top-right`: Posiciona o elemento acima e à direita do componente alvo.
 * - `top-left`: Posiciona o elemento acima e à esquerda do componente alvo.
 *
 * Caso o elemento não caiba na tela na posição indicada ele será rotacionado automaticamente para se adequar,
 * inicialmente no lado definido como padrão e em seguida seguindo o sentido horário.
 * @type {?}
 */
var thfControlPositionSidesDefault = [
    'bottom', 'bottom-left', 'bottom-right',
    'left', 'left-top', 'left-bottom',
    'top', 'top-right', 'top-left',
    'right', 'right-bottom', 'right-top'
];
var ThfControlPositionService = /** @class */ (function () {
    function ThfControlPositionService() {
        this.differenceDiagonalToWidthArrow = 3;
        this.isSetElementWidth = false;
        // offset da seta em relação ao canto do componente
        this.offsetArrow = 12;
    }
    /**
     * @description Ajusta a posição do elemento, caso não couber em tela irá para próxima posição.
     *
     * @param position posição para exibição do elemento
     */
    /**
     * \@description Ajusta a posição do elemento, caso não couber em tela irá para próxima posição.
     *
     * @param {?} position posição para exibição do elemento
     * @return {?}
     */
    ThfControlPositionService.prototype.adjustPosition = /**
     * \@description Ajusta a posição do elemento, caso não couber em tela irá para próxima posição.
     *
     * @param {?} position posição para exibição do elemento
     * @return {?}
     */
    function (position) {
        this.elementPosition(position);
        this.customPositions && this.customPositions.length ? this.adjustCustomPosition(position) : this.adjustDefaultPosition(position);
    };
    /**
     * @description Retorna a direção da seta, conforme a posição do elemento.
     */
    /**
     * \@description Retorna a direção da seta, conforme a posição do elemento.
     * @return {?}
     */
    ThfControlPositionService.prototype.getArrowDirection = /**
     * \@description Retorna a direção da seta, conforme a posição do elemento.
     * @return {?}
     */
    function () {
        return this.arrowDirection;
    };
    /**
     * @description Método responsável por definir as propriedades utilizadas para exibir o elemento na posição correta.
     *
     * @param element elemento que será exibido
     * @param elementOffset offSet do elemento
     * @param targetElement elemento de onde deve partir a exibição
     * @param customPositions posições que sobrescreve as posições padrões
     * @param isSetElementWidth indica se deve definir o tamanho do elemento a ser exibido, caso for verdadeiro será igual do targetElement
     * @param isCornerAligned indica se o elemento filho será alinhado nos cantos do elemneto pai.
     */
    /**
     * \@description Método responsável por definir as propriedades utilizadas para exibir o elemento na posição correta.
     *
     * @param {?} element elemento que será exibido
     * @param {?} elementOffset offSet do elemento
     * @param {?} targetElement elemento de onde deve partir a exibição
     * @param {?=} customPositions posições que sobrescreve as posições padrões
     * @param {?=} isSetElementWidth indica se deve definir o tamanho do elemento a ser exibido, caso for verdadeiro será igual do targetElement
     * @param {?=} isCornerAligned indica se o elemento filho será alinhado nos cantos do elemneto pai.
     * @return {?}
     */
    ThfControlPositionService.prototype.setElements = /**
     * \@description Método responsável por definir as propriedades utilizadas para exibir o elemento na posição correta.
     *
     * @param {?} element elemento que será exibido
     * @param {?} elementOffset offSet do elemento
     * @param {?} targetElement elemento de onde deve partir a exibição
     * @param {?=} customPositions posições que sobrescreve as posições padrões
     * @param {?=} isSetElementWidth indica se deve definir o tamanho do elemento a ser exibido, caso for verdadeiro será igual do targetElement
     * @param {?=} isCornerAligned indica se o elemento filho será alinhado nos cantos do elemneto pai.
     * @return {?}
     */
    function (element, elementOffset, targetElement, customPositions, isSetElementWidth, isCornerAligned) {
        if (isSetElementWidth === void 0) { isSetElementWidth = false; }
        if (isCornerAligned === void 0) { isCornerAligned = false; }
        this.element = (element instanceof core.ElementRef) ? element.nativeElement : element;
        this.targetElement = (targetElement instanceof core.ElementRef) ? targetElement.nativeElement : targetElement;
        this.elementOffset = elementOffset;
        this.customPositions = customPositions;
        this.isSetElementWidth = isSetElementWidth;
        this.isCornerAligned = isCornerAligned;
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    ThfControlPositionService.prototype.adjustCustomPosition = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        /** @type {?} */
        var positionLength = this.customPositions.length;
        /** @type {?} */
        var sidesCount = 0;
        while (sidesCount++ < positionLength) {
            if (this.overflowAllSides(position)) {
                position = this.nextPosition(position, this.customPositions);
                this.elementPosition(position);
            }
        }
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    ThfControlPositionService.prototype.adjustDefaultPosition = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        /** @type {?} */
        var mainPositions = this.getMainPositions();
        /** @type {?} */
        var mainPositionLength = mainPositions.length;
        /** @type {?} */
        var mainSidesCount = 0;
        while (mainSidesCount++ < mainPositionLength) {
            /** @type {?} */
            var mainPosition = this.getMainPosition(position);
            if (this.overflowMain(mainPosition)) {
                position = this.nextPosition(mainPosition, mainPositions);
                continue;
            }
            else if (this.overflowAllSides(position)) {
                this.verifySubPositions(position);
                // TODO: Não está indo para a proxima main position, o problema acontece somente quando utiliza as posições default
                return;
            }
            return;
        }
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    ThfControlPositionService.prototype.elementPosition = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        this.isCornerAligned ? this.setAlignedElementPosition(position) : this.setElementPosition(position);
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    ThfControlPositionService.prototype.getMainPosition = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        return (position.indexOf('-') > -1) ? position.substring(0, position.indexOf('-')) : position;
    };
    /**
     * @private
     * @return {?}
     */
    ThfControlPositionService.prototype.getMainPositions = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var defaultMainPositions = ['top', 'right', 'bottom', 'left'];
        return this.customPositions && this.customPositions.length ?
            this.getMainPositionsByCustomPositions(this.customPositions) : defaultMainPositions;
    };
    /**
     * @private
     * @param {?} customPositions
     * @return {?}
     */
    ThfControlPositionService.prototype.getMainPositionsByCustomPositions = /**
     * @private
     * @param {?} customPositions
     * @return {?}
     */
    function (customPositions) {
        /** @type {?} */
        var mainPositions = [];
        /** @type {?} */
        var customPositionsLength = customPositions.length;
        for (var i = 0; i < customPositionsLength; i++) {
            /** @type {?} */
            var position = customPositions[i];
            /** @type {?} */
            var mainPosition = this.getMainPosition(position);
            if (!mainPositions.includes(mainPosition)) {
                mainPositions.push(mainPosition);
            }
        }
        return mainPositions;
    };
    /**
     * @private
     * @return {?}
     */
    ThfControlPositionService.prototype.getOverflows = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sizesAndPositions = this.getSizesAndPositions();
        return {
            right: (sizesAndPositions.element.right > sizesAndPositions.window.innerWidth),
            top: (sizesAndPositions.element.top <= 0),
            left: (sizesAndPositions.element.left <= 0),
            bottom: (sizesAndPositions.element.bottom > sizesAndPositions.window.innerHeight)
        };
    };
    /**
     * @private
     * @return {?}
     */
    ThfControlPositionService.prototype.getSizesAndPositions = /**
     * @private
     * @return {?}
     */
    function () {
        return {
            window: {
                scrollY: window.scrollY,
                scrollX: window.scrollX,
                innerWidth: window.innerWidth,
                innerHeight: window.innerHeight
            },
            element: this.element.getBoundingClientRect(),
            target: this.targetElement ? this.targetElement.getBoundingClientRect() : { top: 0, bottom: 0, right: 0, left: 0 }
        };
    };
    /**
     * @private
     * @param {?} position
     * @param {?=} positions
     * @return {?}
     */
    ThfControlPositionService.prototype.nextPosition = /**
     * @private
     * @param {?} position
     * @param {?=} positions
     * @return {?}
     */
    function (position, positions) {
        if (positions === void 0) { positions = []; }
        /** @type {?} */
        var index = positions.indexOf(position);
        /** @type {?} */
        var nextIndex = index + 1;
        if (index > -1 && nextIndex < positions.length) {
            return positions[nextIndex];
        }
        else {
            return positions[0];
        }
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    ThfControlPositionService.prototype.overflowAllSides = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        /** @type {?} */
        var overflows = this.getOverflows();
        switch (position) {
            case 'top': return overflows.top || overflows.right || overflows.left;
            case 'top-right': return overflows.top || overflows.right;
            case 'top-left': return overflows.top || overflows.left;
            case 'right': return overflows.right || overflows.top || overflows.bottom;
            case 'right-top': return overflows.right || overflows.top;
            case 'right-bottom': return overflows.right || overflows.bottom;
            case 'bottom': return overflows.bottom || overflows.right || overflows.left;
            case 'bottom-right': return overflows.bottom || overflows.right;
            case 'bottom-left': return overflows.bottom || overflows.left;
            case 'left': return overflows.left || overflows.top || overflows.bottom;
            case 'left-top': return overflows.left || overflows.top;
            case 'left-bottom': return overflows.left || overflows.bottom;
        }
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    ThfControlPositionService.prototype.overflowMain = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        /** @type {?} */
        var overflows = this.getOverflows();
        switch (position) {
            case 'top': return overflows.top;
            case 'right': return overflows.right;
            case 'bottom': return overflows.bottom;
            case 'left': return overflows.left;
        }
    };
    /**
     * @private
     * @param {?} elementPosition
     * @return {?}
     */
    ThfControlPositionService.prototype.setAlignedArrowDirection = /**
     * @private
     * @param {?} elementPosition
     * @return {?}
     */
    function (elementPosition) {
        switch (elementPosition) {
            case 'top-left': return 'bottom-left';
            case 'top-right': return 'bottom-right';
            case 'bottom-right': return 'top-right';
            case 'bottom-left': return 'top-left';
        }
    };
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    ThfControlPositionService.prototype.setAlignedBottomPositions = /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    function (displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.bottom + this.elementOffset + 'px';
        this.element.style.left = sizesAndPositions.target.left - displacement + 'px';
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    ThfControlPositionService.prototype.setAlignedElementPosition = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        this.setElementWidth();
        /** @type {?} */
        var sizesAndPositions = this.getSizesAndPositions();
        switch (position) {
            case 'bottom-left':
                this.setAlignedBottomPositions(0, sizesAndPositions);
                break;
            case 'bottom-right':
                this.setAlignedBottomPositions(sizesAndPositions.element.width - sizesAndPositions.target.width, sizesAndPositions);
                break;
            case 'top-left':
                this.setAlignedTopPositions(0, sizesAndPositions);
                break;
            case 'top-right':
                this.setAlignedTopPositions(sizesAndPositions.element.width - sizesAndPositions.target.width, sizesAndPositions);
                break;
        }
        this.arrowDirection = this.setAlignedArrowDirection(position);
    };
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    ThfControlPositionService.prototype.setAlignedTopPositions = /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    function (displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.top - sizesAndPositions.element.height - this.elementOffset + 'px';
        this.element.style.left = sizesAndPositions.target.left - displacement + 'px';
    };
    /**
     * @private
     * @param {?} elementPosition
     * @return {?}
     */
    ThfControlPositionService.prototype.setArrowDirection = /**
     * @private
     * @param {?} elementPosition
     * @return {?}
     */
    function (elementPosition) {
        switch (elementPosition) {
            case 'top': return 'bottom';
            case 'top-left': return 'bottom-right';
            case 'top-right': return 'bottom-left';
            case 'right': return 'left';
            case 'right-top': return 'left-bottom';
            case 'right-bottom': return 'left-top';
            case 'bottom': return 'top';
            case 'bottom-right': return 'top-left';
            case 'bottom-left': return 'top-right';
            case 'left': return 'right';
            case 'left-bottom': return 'right-top';
            case 'left-top': return 'right-bottom';
        }
    };
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    ThfControlPositionService.prototype.setBottomPositions = /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    function (displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.bottom + this.elementOffset + 'px';
        this.element.style.left = sizesAndPositions.target.left + (sizesAndPositions.target.width / 2) - displacement + 'px';
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    ThfControlPositionService.prototype.setElementPosition = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        this.setElementWidth();
        /** @type {?} */
        var sizesAndPositions = this.getSizesAndPositions();
        switch (position) {
            case 'top':
                this.setTopPositions((sizesAndPositions.element.width / 2), sizesAndPositions);
                break;
            case 'top-left':
                this.setTopPositions((sizesAndPositions.element.width - this.offsetArrow - this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'top-right':
                this.setTopPositions((this.offsetArrow + this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'right':
                this.setRightPositions((sizesAndPositions.element.height / 2), sizesAndPositions);
                break;
            case 'right-top':
                this.setRightPositions((sizesAndPositions.element.height - this.offsetArrow - this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'right-bottom':
                this.setRightPositions(this.offsetArrow, sizesAndPositions);
                break;
            case 'bottom':
                this.setBottomPositions((sizesAndPositions.element.width / 2), sizesAndPositions);
                break;
            case 'bottom-right':
                this.setBottomPositions((this.offsetArrow + this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'bottom-left':
                this.setBottomPositions((sizesAndPositions.element.width - this.offsetArrow - this.differenceDiagonalToWidthArrow), sizesAndPositions);
                break;
            case 'left':
                this.setLeftPositions((sizesAndPositions.element.height / 2), sizesAndPositions);
                break;
            case 'left-bottom':
                this.setLeftPositions(this.offsetArrow, sizesAndPositions);
                break;
            case 'left-top':
                this.setLeftPositions((sizesAndPositions.element.height - this.offsetArrow), sizesAndPositions);
                break;
        }
        this.arrowDirection = this.setArrowDirection(position);
    };
    /**
     * @private
     * @return {?}
     */
    ThfControlPositionService.prototype.setElementWidth = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.isSetElementWidth && this.targetElement) {
            this.element.style.width = this.targetElement.clientWidth + "px";
        }
    };
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    ThfControlPositionService.prototype.setLeftPositions = /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    function (displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.top - displacement + (sizesAndPositions.target.height / 2) + 'px';
        this.element.style.left = sizesAndPositions.target.left - sizesAndPositions.element.width - this.elementOffset + 'px';
    };
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    ThfControlPositionService.prototype.setRightPositions = /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    function (displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.top - displacement + (sizesAndPositions.target.height / 2) + 'px';
        this.element.style.left = sizesAndPositions.target.right + this.elementOffset + 'px';
    };
    /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    ThfControlPositionService.prototype.setTopPositions = /**
     * @private
     * @param {?} displacement
     * @param {?} sizesAndPositions
     * @return {?}
     */
    function (displacement, sizesAndPositions) {
        this.element.style.top = sizesAndPositions.target.top - sizesAndPositions.element.height - this.elementOffset + 'px';
        this.element.style.left = sizesAndPositions.target.left + (sizesAndPositions.target.width / 2) - displacement + 'px';
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    ThfControlPositionService.prototype.verifySubPositions = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        if (position.indexOf('-') > -1) {
            position = position.substring(0, position.indexOf('-'));
            this.elementPosition(position);
        }
        /** @type {?} */
        var align = 0;
        while (align++ < 3) {
            if (this.overflowAllSides(position)) {
                position = this.nextPosition(position, this.customPositions || thfControlPositionSidesDefault);
                this.elementPosition(position);
            }
            else {
                return null;
            }
        }
    };
    ThfControlPositionService.decorators = [
        { type: core.Injectable },
    ];
    return ThfControlPositionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Array de posições.
/** @type {?} */
var THF_CONTROL_POSITIONS = [
    'right',
    'right-top',
    'right-bottom',
    'top',
    'top-left',
    'top-right',
    'left',
    'left-top',
    'left-bottom',
    'bottom',
    'bottom-left',
    'bottom-right'
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var thfPopupDefaultPosition = 'bottom-left';
/**
 * \@description
 *
 * O componente `thf-popup` é um container pequeno recomendado para ações de navegação:
 * Ele abre sobreposto aos outros componentes.
 *
 * É possível escolher as posições do `thf-popup` em relação ao componente alvo, para isto veja a propriedade `t-position`.
 *
 * Também é possível informar um _template_ _header_ para o `thf-popup`, que será exibido acima das ações.
 * Para funcionar corretamente é preciso adicionar a propriedade `t-popup-header-template` no elemento que servirá de template, por exemplo:
 *
 * ```
 * <thf-popup [t-target]="target">
 *   <div t-popup-header-template>
 *     <div>
 *       Dev Totvs
 *     </div>
 *     <div>
 *       dev.totvs\@totvs.com.br
 *     </div>
 *   </div>
 * </thf-popup >
 * ```
 */
var ThfPopupBaseComponent = /** @class */ (function () {
    function ThfPopupBaseComponent() {
        this._hideArrow = false;
        this._position = thfPopupDefaultPosition;
        this.arrowDirection = 'top-right';
        this.showPopup = false;
    }
    Object.defineProperty(ThfPopupBaseComponent.prototype, "actions", {
        get: /**
         * @return {?}
         */
        function () {
            return this._actions;
        },
        /** Lista de ações que serão exibidas no componente. */
        set: /**
         * Lista de ações que serão exibidas no componente.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._actions = Array.isArray(value) ? value : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfPopupBaseComponent.prototype, "hideArrow", {
        get: /**
         * @return {?}
         */
        function () {
            return this._hideArrow;
        },
        /**
         * @optional
         *
         * @description
         *
         * Oculta a seta do componente *popup*.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Oculta a seta do componente *popup*.
         *
         * \@default `false`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hideArrow = convertToBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfPopupBaseComponent.prototype, "position", {
        get: /**
         * @return {?}
         */
        function () {
            return this._position;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define a posição que o `thf-popup` abrirá em relação ao componente alvo. Sugere-se que seja
         * usada a orientação `bottom-left` (abaixo e a esquerda), porém o mesmo é flexível e será rotacionado
         * automaticamente para se adequar a tela, caso necessário.
         *
         * Posições válidas:
         * - `right`: Posiciona o thf-popup no lado direito do componente alvo.
         * - `right-bottom`: Posiciona o thf-popup no lado direito inferior do componente alvo.
         * - `right-top`: Posiciona o thf-popup no lado direito superior do componente alvo.
         * - `bottom`: Posiciona o thf-popup abaixo do componente alvo.
         * - `bottom-left`: Posiciona o thf-popup abaixo e à esquerda do componente alvo.
         * - `bottom-right`: Posiciona o thf-popup abaixo e à direita do componente alvo.
         * - `left`: Posiciona o thf-popup no lado esquerdo do componente alvo.
         * - `left-top`: Posiciona o thf-popup no lado esquerdo superior do componente alvo.
         * - `left-bottom`: Posiciona o thf-popup no lado esquerdo inferior do componente alvo.
         * - `top`: Posiciona o thf-popup acima do componente alvo.
         * - `top-right`: Posiciona o thf-popup acima e à direita do componente alvo.
         * - `top-left`: Posiciona o thf-popup acima e à esquerda do componente alvo.
         *
         * @default `bottom-left`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define a posição que o `thf-popup` abrirá em relação ao componente alvo. Sugere-se que seja
         * usada a orientação `bottom-left` (abaixo e a esquerda), porém o mesmo é flexível e será rotacionado
         * automaticamente para se adequar a tela, caso necessário.
         *
         * Posições válidas:
         * - `right`: Posiciona o thf-popup no lado direito do componente alvo.
         * - `right-bottom`: Posiciona o thf-popup no lado direito inferior do componente alvo.
         * - `right-top`: Posiciona o thf-popup no lado direito superior do componente alvo.
         * - `bottom`: Posiciona o thf-popup abaixo do componente alvo.
         * - `bottom-left`: Posiciona o thf-popup abaixo e à esquerda do componente alvo.
         * - `bottom-right`: Posiciona o thf-popup abaixo e à direita do componente alvo.
         * - `left`: Posiciona o thf-popup no lado esquerdo do componente alvo.
         * - `left-top`: Posiciona o thf-popup no lado esquerdo superior do componente alvo.
         * - `left-bottom`: Posiciona o thf-popup no lado esquerdo inferior do componente alvo.
         * - `top`: Posiciona o thf-popup acima do componente alvo.
         * - `top-right`: Posiciona o thf-popup acima e à direita do componente alvo.
         * - `top-left`: Posiciona o thf-popup acima e à esquerda do componente alvo.
         *
         * \@default `bottom-left`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._position = THF_CONTROL_POSITIONS.includes(value) ? value : thfPopupDefaultPosition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfPopupBaseComponent.prototype, "target", {
        get: /**
         * @return {?}
         */
        function () {
            return this._target;
        },
        /**
         * @description
         *
         * Para utilizar o `thf-popup` deve-se colocar uma variável local no componente que disparará o evento
         * de abertura no mesmo e com isso, invocará a função `toggle`, por exemplo:
         *
         * ```
         * <span #icon class="thf-icon thf-icon-credit-payment" (click)="popup.toggle()">
         *   Credit Actions
         * </span>
         *
         * <thf-popup #popup
         *   [t-actions]="actions"
         *   [t-target]="icon">
         * </thf-popup>
         * ```
         *
         * Caso o elemento alvo for um componente, será preciso obter o `ElementRef` do mesmo e passá-lo à propriedade, por exemplo:
         *
         * ```
         * // component.html
         *
         * <thf-button #thfButton
         *   t-label="Open Popover"
         *   (t-click)="popup.toggle()">
         * </thf-button>
         *
         * <thf-popup #popup
         *   [t-actions]="actions"
         *   [t-target]="thfButtonRef">
         * </thf-popup>
         *
         * // component.ts
         *
         * @ViewChild('thfButton', { read: ElementRef }) thfButtonRef: ElementRef;
         * ```
         */
        set: /**
         * \@description
         *
         * Para utilizar o `thf-popup` deve-se colocar uma variável local no componente que disparará o evento
         * de abertura no mesmo e com isso, invocará a função `toggle`, por exemplo:
         *
         * ```
         * <span #icon class="thf-icon thf-icon-credit-payment" (click)="popup.toggle()">
         *   Credit Actions
         * </span>
         *
         * <thf-popup #popup
         *   [t-actions]="actions"
         *   [t-target]="icon">
         * </thf-popup>
         * ```
         *
         * Caso o elemento alvo for um componente, será preciso obter o `ElementRef` do mesmo e passá-lo à propriedade, por exemplo:
         *
         * ```
         * // component.html
         *
         * <thf-button #thfButton
         *   t-label="Open Popover"
         *   (t-click)="popup.toggle()">
         * </thf-button>
         *
         * <thf-popup #popup
         *   [t-actions]="actions"
         *   [t-target]="thfButtonRef">
         * </thf-popup>
         *
         * // component.ts
         *
         * \@ViewChild('thfButton', { read: ElementRef }) thfButtonRef: ElementRef;
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._target = (value instanceof core.ElementRef) ? value.nativeElement : value;
        },
        enumerable: true,
        configurable: true
    });
    ThfPopupBaseComponent.propDecorators = {
        actions: [{ type: core.Input, args: ['t-actions',] }],
        hideArrow: [{ type: core.Input, args: ['t-hide-arrow',] }],
        position: [{ type: core.Input, args: ['t-position',] }],
        target: [{ type: core.Input, args: ['t-target',] }]
    };
    return ThfPopupBaseComponent;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@docsExtends ThfPopupBaseComponent
 *
 * \@example
 *
 * <example name="thf-popup-basic" title="Totvs Popup - Basic">
 *   <file name="sample-thf-popup-basic/sample-thf-popup-basic.component.html"> </file>
 *   <file name="sample-thf-popup-basic/sample-thf-popup-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-popup-labs" title="Totvs Popup - Labs">
 *   <file name="sample-thf-popup-labs/sample-thf-popup-labs.component.html"> </file>
 *   <file name="sample-thf-popup-labs/sample-thf-popup-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-popup-email" title="Totvs Popup Email">
 *   <file name="sample-thf-popup-email/sample-thf-popup-email.component.html"> </file>
 *   <file name="sample-thf-popup-email/sample-thf-popup-email.component.ts"> </file>
 * </example>
 *
 */
var ThfPopupComponent = /** @class */ (function (_super) {
    __extends(ThfPopupComponent, _super);
    function ThfPopupComponent(viewContainerRef, renderer, router$$1, thfControlPosition, changeDetector) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        _this.router = router$$1;
        _this.thfControlPosition = thfControlPosition;
        _this.changeDetector = changeDetector;
        _this.onScroll = function () {
            if (_this.showPopup) {
                _this.close();
            }
        };
        _this.parentRef = viewContainerRef['_view']['component'];
        return _this;
    }
    /**
     * Fecha o componente *popup*.
     *
     * > Por padrão, este comportamento é acionado somente ao clicar fora do componente ou em determinada ação / url.
     */
    /**
     * Fecha o componente *popup*.
     *
     * > Por padrão, este comportamento é acionado somente ao clicar fora do componente ou em determinada ação / url.
     * @return {?}
     */
    ThfPopupComponent.prototype.close = /**
     * Fecha o componente *popup*.
     *
     * > Por padrão, este comportamento é acionado somente ao clicar fora do componente ou em determinada ação / url.
     * @return {?}
     */
    function () {
        this.removeListeners();
        this.showPopup = false;
    };
    /**
     * @param {?} popupAction
     * @return {?}
     */
    ThfPopupComponent.prototype.onActionClick = /**
     * @param {?} popupAction
     * @return {?}
     */
    function (popupAction) {
        /** @type {?} */
        var actionNoDisabled = popupAction && !this.returnBooleanValue(popupAction, 'disabled');
        if (popupAction && popupAction.action && actionNoDisabled) {
            this.close();
            return callFunction(popupAction.action, this.parentRef, this.param || popupAction);
        }
        if (popupAction && popupAction.url && actionNoDisabled) {
            this.close();
            return this.openUrl(popupAction.url);
        }
    };
    /**
     * Abre o componente *popup*.
     *
     * > É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
     */
    /**
     * Abre o componente *popup*.
     *
     * > É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
     * @param {?=} param
     * @return {?}
     */
    ThfPopupComponent.prototype.open = /**
     * Abre o componente *popup*.
     *
     * > É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
     * @param {?=} param
     * @return {?}
     */
    function (param) {
        this.oldTarget = this.target;
        this.param = param;
        this.showPopup = true;
        this.changeDetector.detectChanges();
        this.validateInitialContent();
    };
    /**
     * @param {?} popupAction
     * @param {?} property
     * @return {?}
     */
    ThfPopupComponent.prototype.returnBooleanValue = /**
     * @param {?} popupAction
     * @param {?} property
     * @return {?}
     */
    function (popupAction, property) {
        return isTypeof(popupAction[property], 'function') ? popupAction[property](this.param || popupAction) : popupAction[property];
    };
    /**
     * Responsável por abrir e fechar o *popup*.
     *
     * Quando disparado abrirá o *popup* e caso o mesmo já estiver aberto e possuir o mesmo `target` irá fecha-lo.
     *
     * É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
     */
    /**
     * Responsável por abrir e fechar o *popup*.
     *
     * Quando disparado abrirá o *popup* e caso o mesmo já estiver aberto e possuir o mesmo `target` irá fecha-lo.
     *
     * É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
     * @param {?=} param
     * @return {?}
     */
    ThfPopupComponent.prototype.toggle = /**
     * Responsável por abrir e fechar o *popup*.
     *
     * Quando disparado abrirá o *popup* e caso o mesmo já estiver aberto e possuir o mesmo `target` irá fecha-lo.
     *
     * É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
     * @param {?=} param
     * @return {?}
     */
    function (param) {
        this.showPopup && this.oldTarget === this.target ? this.close() : this.open(param);
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfPopupComponent.prototype.clickedOutDisabledItem = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var containsItemDisabled = this.elementContains(event.target, 'thf-popup-item-disabled') ||
            this.elementContains(event.target.parentElement, 'thf-popup-item-disabled');
        return !containsItemDisabled;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfPopupComponent.prototype.clickedOutHeaderTemplate = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var popupHeaderTemplate = this.popupRef && this.popupRef.nativeElement.querySelector('[t-popup-header-template]');
        return !(popupHeaderTemplate && popupHeaderTemplate.contains(event.target));
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfPopupComponent.prototype.clickedOutTarget = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return this.target && !this.target.contains(event.target);
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ThfPopupComponent.prototype.closePopupOnClickout = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.clickedOutTarget(event) && this.clickedOutDisabledItem(event) && this.clickedOutHeaderTemplate(event)) {
            this.close();
        }
    };
    /**
     * @private
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    ThfPopupComponent.prototype.elementContains = /**
     * @private
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    function (element, className) {
        return element && element.classList.contains(className);
    };
    /**
     * @private
     * @return {?}
     */
    ThfPopupComponent.prototype.hasContentToShow = /**
     * @private
     * @return {?}
     */
    function () {
        return !!(this.popupRef.nativeElement && this.popupRef.nativeElement.clientHeight);
    };
    /**
     * @private
     * @return {?}
     */
    ThfPopupComponent.prototype.initializeListeners = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.resizeListener = this.renderer.listen('window', 'resize', function () {
            _this.close();
        });
        this.clickoutListener = this.renderer.listen('document', 'click', function (event) {
            _this.closePopupOnClickout(event);
        });
        window.addEventListener('scroll', this.onScroll, true);
    };
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    ThfPopupComponent.prototype.openUrl = /**
     * @private
     * @param {?} url
     * @return {?}
     */
    function (url) {
        if (isExternalLink(url)) {
            return openExternalLink(url);
        }
        if (url) {
            return this.router.navigate([url]);
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfPopupComponent.prototype.removeListeners = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.clickoutListener) {
            this.clickoutListener();
        }
        if (this.resizeListener) {
            this.resizeListener();
        }
        window.removeEventListener('scroll', this.onScroll, true);
    };
    /**
     * @private
     * @return {?}
     */
    ThfPopupComponent.prototype.setPosition = /**
     * @private
     * @return {?}
     */
    function () {
        this.thfControlPosition.setElements(this.popupRef.nativeElement, 8, this.target);
        this.renderer.setStyle(this.popupRef.nativeElement, 'left', '0');
        this.thfControlPosition.adjustPosition(this.position);
        this.arrowDirection = this.thfControlPosition.getArrowDirection();
    };
    /**
     * @private
     * @return {?}
     */
    ThfPopupComponent.prototype.validateInitialContent = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.hasContentToShow()) {
            this.setPosition();
            this.initializeListeners();
        }
        else {
            this.close();
        }
    };
    ThfPopupComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-popup', template: "<div #popupRef class=\"thf-popup\" *ngIf=\"showPopup\"> <div *ngIf=\"!hideArrow\" class=\"thf-popup-arrow thf-arrow-{{ arrowDirection }}\"></div> <ng-content select=\"[t-popup-header-template]\"></ng-content> <ng-container *ngFor=\"let action of actions; let actionIndex = index\"> <div *ngIf=\"action.visible !== false\" [class.thf-popup-item-default]=\"action.type !== 'danger'\" [class.thf-popup-item-danger]=\"action.type === 'danger'\" [class.thf-popup-item-disabled]=\"returnBooleanValue(action, 'disabled')\" [class.thf-popup-item-separator]=\"action.separator && actionIndex !== 0\" [class.thf-popup-item-selected]=\"action.selected\" (click)=\"onActionClick(action)\"> <span *ngIf=\"action.icon\" class=\"thf-icon {{ action.icon }} thf-popup-icon-item\"></span> {{ action.label }} </div> </ng-container> </div> ",
                    providers: [ThfControlPositionService]
                },] },
    ];
    /** @nocollapse */
    ThfPopupComponent.ctorParameters = function () { return [
        { type: core.ViewContainerRef },
        { type: core.Renderer2 },
        { type: router.Router },
        { type: ThfControlPositionService },
        { type: core.ChangeDetectorRef }
    ]; };
    ThfPopupComponent.propDecorators = {
        popupRef: [{ type: core.ViewChild, args: ['popupRef', { read: core.ElementRef },] }]
    };
    return ThfPopupComponent;
}(ThfPopupBaseComponent));

var __assign$1 = (undefined && undefined.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var thfTableContainer = ['border', 'shadow'];
/** @type {?} */
var thfTableContainerDefault = 'border';
/** @type {?} */
var thfTableLiteralsDefault = {
    en: (/** @type {?} */ ({
        noColumns: 'Columns are not defined',
        noData: 'No data found',
        loadingData: 'Loading',
        loadMoreData: 'Load more data',
        seeCompleteSubtitle: 'See complete subtitle',
        completeSubtitle: 'Complete subtitle'
    })),
    es: (/** @type {?} */ ({
        noColumns: 'Columnas no definidas',
        noData: 'Datos no encontrados',
        loadingData: 'Cargando datos',
        loadMoreData: 'Cargar más resultados',
        seeCompleteSubtitle: 'Ver subtitulo completo',
        completeSubtitle: 'Subtitulo completo'
    })),
    pt: (/** @type {?} */ ({
        noColumns: 'Nenhuma definição de colunas',
        noData: 'Nenhum dado encontrado',
        loadingData: 'Carregando',
        loadMoreData: 'Carregar mais resultados',
        seeCompleteSubtitle: 'Ver legenda completa',
        completeSubtitle: 'Legenda completa'
    }))
};
/**
 * \@description
 *
 * Este componente de tabela é utilizado para exibição de listas, com diferentes tipos de dados que podem ser texto,
 * data, horário e número com formato personalizado.
 *
 * É possivel criar uma tabela com ordenação de dados, linhas com detalhes, coluna de seleção de linhas,
 * coluna com ações e também carregamento por demanda com o botão "Carregar mais resultados".
 *
 * Também existe a possibilidade de utilizar _template_ para os detalhes das linhas,
 * veja mais em **[t-table-row-template](/documentation/thf-table-row-template)**.
 *
 * Quando a largura de todas as colunas for definida, caso o tamanho total delas seja maior que a tabela, será exibido um scroll horizontal.
 *
 * @abstract
 */
var ThfTableBaseComponent = /** @class */ (function () {
    function ThfTableBaseComponent(thfDate) {
        this.thfDate = thfDate;
        this._actions = [];
        this._columns = [];
        this._hideDetail = false;
        this._hideTextOverflow = false;
        this._loading = false;
        /**
         * Ação executada quando todas as linhas são selecionadas por meio do *checkbox* que seleciona todas as linhas.
         */
        this.allSelected = new core.EventEmitter();
        /**
         * Ação executada quando a seleção das linhas é desmarcada por meio do *checkbox* que seleciona todas as linhas.
         */
        this.allUnselected = new core.EventEmitter();
        /**
         * Ação executada ao selecionar uma linha do `thf-table`.
         */
        this.selected = new core.EventEmitter();
        /**
         * Recebe uma ação de clique para o botão "Carregar mais resultados", caso nenhuma ação for definida o mesmo
         * não é visível.
         */
        this.showMore = new core.EventEmitter();
        /**
         * Ação executada ao desmarcar a seleção de uma linha do `thf-table`.
         */
        this.unselected = new core.EventEmitter();
        this.selectAll = false;
        this.sortedColumn = { property: (/** @type {?} */ (null)), ascending: true };
    }
    Object.defineProperty(ThfTableBaseComponent.prototype, "items", {
        get: /**
         * @return {?}
         */
        function () {
            return this._items;
        },
        /**
         * @description
         *
         * Lista de itens da tabela.
         * > Se falso, será inicializado como um *array* vazio.
         */
        set: /**
         * \@description
         *
         * Lista de itens da tabela.
         * > Se falso, será inicializado como um *array* vazio.
         * @param {?} items
         * @return {?}
         */
        function (items) {
            this._items = Array.isArray(items) ? items : [];
            // when haven't items, selectAll should be unchecked.
            if (!this.hasItems()) {
                this.selectAll = false;
            }
            else if (!this.hasColumns()) {
                this.columns = this.getDefaultColumns(items[0]);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "columns", {
        get: /**
         * @return {?}
         */
        function () {
            return this._columns;
        },
        /**
         * @optional
         *
         * @description
         *
         * Lista das colunas da tabela, deve receber um *array* de objetos que implementam a interface `ThfTableColumn`.
         * Por padrão receberá como valor a primeira coluna da lista de itens da tabela.
         * > Caso não encontre valor, a mensagem 'Nenhuma definição de colunas' será exibida.
         *
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Lista das colunas da tabela, deve receber um *array* de objetos que implementam a interface `ThfTableColumn`.
         * Por padrão receberá como valor a primeira coluna da lista de itens da tabela.
         * > Caso não encontre valor, a mensagem 'Nenhuma definição de colunas' será exibida.
         *
         * @param {?} columns
         * @return {?}
         */
        function (columns) {
            this._columns = columns || [];
            this.mapColumnToProperty();
            if (this._columns.length) {
                this.setColumnLink();
                this.calculateWidthHeaders();
            }
            else if (this.hasItems()) {
                this._columns = this.getDefaultColumns(this.items[0]);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "container", {
        get: /**
         * @return {?}
         */
        function () {
            return this._container;
        },
        /**
         * @optional
         *
         * @description
         *
         * Adiciona um contorno arredondado ao `thf-table`, as opções são:
         * - `border`: com bordas/linhas.
         * - `shadow`: com sombras.
         *
         * @default `border`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Adiciona um contorno arredondado ao `thf-table`, as opções são:
         * - `border`: com bordas/linhas.
         * - `shadow`: com sombras.
         *
         * \@default `border`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._container = thfTableContainer.includes(value) ? value : thfTableContainerDefault;
            this.showContainer(this._container);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "hideTextOverflow", {
        get: /**
         * @return {?}
         */
        function () {
            return this._hideTextOverflow;
        },
        /**
         * @optional
         *
         * @description
         *
         * Se verdadeiro, habilita a quebra de texto ao transborda-lo dentro de qualquer coluna.
         * > Quando ocorrer a quebra de texto, ao passar o mouse no conteúdo da célula,
         * o mesmo será exibido através do [`thf-tooltip`](/documentation/thf-tooltip).
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Se verdadeiro, habilita a quebra de texto ao transborda-lo dentro de qualquer coluna.
         * > Quando ocorrer a quebra de texto, ao passar o mouse no conteúdo da célula,
         * o mesmo será exibido através do [`thf-tooltip`](/documentation/thf-tooltip).
         * @param {?} hideTextOverflow
         * @return {?}
         */
        function (hideTextOverflow) {
            this._hideTextOverflow = convertToBoolean(hideTextOverflow);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "height", {
        get: /**
         * @return {?}
         */
        function () {
            return this._height;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define a altura da tabela em *pixels* e fixa o cabeçalho.
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define a altura da tabela em *pixels* e fixa o cabeçalho.
         * @param {?} height
         * @return {?}
         */
        function (height) {
            this._height = height;
            this.calculateHeightTableContainer(height);
            this.calculateWidthHeaders();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "hideDetail", {
        get: /**
         * @return {?}
         */
        function () {
            return this._hideDetail;
        },
        /**
         * @optional
         *
         * @description
         *
         * Habilita a visualização da lista de detalhes de cada linha da coluna.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Habilita a visualização da lista de detalhes de cada linha da coluna.
         *
         * \@default `false`
         * @param {?} hideDetail
         * @return {?}
         */
        function (hideDetail) {
            this._hideDetail = hideDetail != null && hideDetail.toString() === '' ? true : convertToBoolean(hideDetail);
            this.calculateWidthHeaders();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "literals", {
        get: /**
         * @return {?}
         */
        function () {
            return this._literals || thfTableLiteralsDefault[browserLanguage()];
        },
        /**
         * @optional
         *
         * @description
         *
         * Objeto com as literais usadas no `thf-table`.
         *
         * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
         *
         * ```
         *  const customLiterals: ThfTableLiterals = {
         *    loadMoreData: 'Buscar mais dados',
         *    loadingData: 'Processando',
         *    noColumns: 'Sem colunas',
         *    noData: 'Sem dados',
         *    seeCompleteSubtitle: 'Mostrar legenda completa',
         *    completeSubtitle: 'Todas legendas'
         *  };
         * ```
         *
         * Ou passando apenas as literais que deseja customizar:
         *
         * ```
         *  const customLiterals: ThfTableLiterals = {
         *    noData: 'Sem dados'
         *  };
         * ```
         *
         * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
         *
         * ```
         * <thf-table
         *   [t-literals]="customLiterals">
         * </thf-table>
         * ```
         *
         *  > O objeto padrão de literais será traduzido de acordo com o idioma do *browser* (pt, en, es).
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Objeto com as literais usadas no `thf-table`.
         *
         * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
         *
         * ```
         *  const customLiterals: ThfTableLiterals = {
         *    loadMoreData: 'Buscar mais dados',
         *    loadingData: 'Processando',
         *    noColumns: 'Sem colunas',
         *    noData: 'Sem dados',
         *    seeCompleteSubtitle: 'Mostrar legenda completa',
         *    completeSubtitle: 'Todas legendas'
         *  };
         * ```
         *
         * Ou passando apenas as literais que deseja customizar:
         *
         * ```
         *  const customLiterals: ThfTableLiterals = {
         *    noData: 'Sem dados'
         *  };
         * ```
         *
         * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
         *
         * ```
         * <thf-table
         *   [t-literals]="customLiterals">
         * </thf-table>
         * ```
         *
         *  > O objeto padrão de literais será traduzido de acordo com o idioma do *browser* (pt, en, es).
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value instanceof Object && !(value instanceof Array)) {
                this._literals = __assign$1({}, thfTableLiteralsDefault[thfLocaleDefault], thfTableLiteralsDefault[browserLanguage()], value);
            }
            else {
                this._literals = thfTableLiteralsDefault[browserLanguage()];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "loading", {
        get: /**
         * @return {?}
         */
        function () {
            return this._loading;
        },
        /**
         * @optional
         *
         * @description
         *
         * Bloqueia interação do usuário com os dados da _table_, apresentando um _loading_ ao centro da mesma.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Bloqueia interação do usuário com os dados da _table_, apresentando um _loading_ ao centro da mesma.
         *
         * \@default `false`
         * @param {?} loading
         * @return {?}
         */
        function (loading) {
            this._loading = convertToBoolean(loading);
            this.calculateWidthHeaders();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "checkbox", {
        get: /**
         * @return {?}
         */
        function () {
            return this._checkbox;
        },
        /**
         * @optional
         *
         * @description
         *
         * Habilita na primeira coluna a opção de selecionar linhas,
         * todos os itens da lista possuem a propriedade dinâmica `$selected` para identificar se a linha está selecionada.
         * > Exemplo: `item.$selected` ou `item['$selected']`.
         * > Os itens filhos possuem comportamento independente do item pai.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Habilita na primeira coluna a opção de selecionar linhas,
         * todos os itens da lista possuem a propriedade dinâmica `$selected` para identificar se a linha está selecionada.
         * > Exemplo: `item.$selected` ou `item['$selected']`.
         * > Os itens filhos possuem comportamento independente do item pai.
         *
         * \@default `false`
         * @param {?} checkbox
         * @return {?}
         */
        function (checkbox) {
            this._checkbox = (/** @type {?} */ (checkbox)) === '' ? true : convertToBoolean(checkbox);
            this.calculateWidthHeaders();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "actions", {
        get: /**
         * @return {?}
         */
        function () {
            return this._actions;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define uma lista de ações.
         *
         * Quando houver apenas uma ação definida ela será exibida diretamente na coluna, caso contrário, o componente
         * se encarrega de agrupá-las exibindo o ícone [**thf-icon-more**](/guides/icons) que listará as ações ao ser clicado.
         *
         * **A coluna de ações não será exibida quando:**
         *  - a lista conter valores inválidos ou indefinidos.
         *  - tenha uma única ação e a mesma não for visível.
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define uma lista de ações.
         *
         * Quando houver apenas uma ação definida ela será exibida diretamente na coluna, caso contrário, o componente
         * se encarrega de agrupá-las exibindo o ícone [**thf-icon-more**](/guides/icons) que listará as ações ao ser clicado.
         *
         * **A coluna de ações não será exibida quando:**
         *  - a lista conter valores inválidos ou indefinidos.
         *  - tenha uma única ação e a mesma não for visível.
         * @param {?} actions
         * @return {?}
         */
        function (actions) {
            this._actions = actions;
            this.calculateWidthHeaders();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "setSort", {
        set: /**
         * @param {?} sort
         * @return {?}
         */
        function (sort) {
            this.sort = sort === '' ? false : convertToBoolean(sort);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "setShowMoreDisabled", {
        set: /**
         * @param {?} showMoreDisabled
         * @return {?}
         */
        function (showMoreDisabled) {
            this.showMoreDisabled = showMoreDisabled === '' ? false : convertToBoolean(showMoreDisabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "setStriped", {
        set: /**
         * @param {?} striped
         * @return {?}
         */
        function (striped) {
            this.striped = striped === '' ? false : convertToBoolean(striped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "setHideSelectAll", {
        set: /**
         * @param {?} hideSelectAll
         * @return {?}
         */
        function (hideSelectAll) {
            this.hideSelectAll = hideSelectAll === '' ? false : convertToBoolean(hideSelectAll);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "setSingleSelect", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.singleSelect = value === '' ? true : convertToBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableBaseComponent.prototype, "noData", {
        get: /**
         * @return {?}
         */
        function () {
            return this.literals.noData;
        },
        /**
         * @deprecated 4.x.x
         *
         * @optional
         *
         * @description
         *
         * Texto que será apresentado quando a tabela não houver dados.
         *
         * > Veja a nova propriedade `t-literals`
         *
         * @default **Nenhum dado encontrado.**
         */
        set: /**
         * @deprecated 4.x.x
         *
         * \@optional
         *
         * \@description
         *
         * Texto que será apresentado quando a tabela não houver dados.
         *
         * > Veja a nova propriedade `t-literals`
         *
         * \@default **Nenhum dado encontrado.**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.literals.noData = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        if (this.singleSelect || this.hideSelectAll) {
            this.selectAll = false;
            this.hideSelectAll = true;
        }
    };
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.selectAllRows = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.hideSelectAll) {
            this.selectAll = !this.selectAll;
            this.items.forEach(function (item) {
                item.$selected = _this.selectAll;
            });
            this.emitSelectAllEvents(this.selectAll, this.items);
        }
    };
    /**
     * @param {?} row
     * @return {?}
     */
    ThfTableBaseComponent.prototype.selectRow = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        row.$selected = !row.$selected;
        this.emitSelectEvents(row);
        this.configAfterSelectRow(this.items, row);
    };
    /**
     * @param {?} row
     * @return {?}
     */
    ThfTableBaseComponent.prototype.selectDetailRow = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        this.emitSelectEvents(row);
    };
    // Colunas que são inseridas no <head> da tabela
    // Colunas que são inseridas no <head> da tabela
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getMainColumns = 
    // Colunas que são inseridas no <head> da tabela
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var typesValid = ['string', 'number', 'boolean', 'date', 'time', 'dateTime', 'currency', 'subtitle', 'link', 'label', 'icon'];
        return this.columns.filter(function (col) { return !col.type || typesValid.includes(col.type); });
    };
    // Retorna a coluna da lista de colunas que é do tipo detail
    // Retorna a coluna da lista de colunas que é do tipo detail
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getColumnMasterDetail = 
    // Retorna a coluna da lista de colunas que é do tipo detail
    /**
     * @return {?}
     */
    function () {
        return this.columns.find(function (col) { return col.type === 'detail'; });
    };
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getClassColor = /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    function (row, column) {
        return column.color ? "thf-column-text-" + this.getColumnColor(row, column) : '';
    };
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getColumnColor = /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    function (row, column) {
        /** @type {?} */
        var columnColor = column.color;
        return isTypeof(columnColor, 'function') ? columnColor(row, column.property) : columnColor;
    };
    // Retorna as colunas com status
    // Retorna as colunas com status
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getSubtitleColumns = 
    // Retorna as colunas com status
    /**
     * @return {?}
     */
    function () {
        return this.columns.filter(function (col) { return col.type === 'subtitle'; });
    };
    // Retorna as colunas com ícones
    // Retorna as colunas com ícones
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getIconColumns = 
    // Retorna as colunas com ícones
    /**
     * @return {?}
     */
    function () {
        return this.columns.filter(function (col) { return col.type === 'icon'; });
    };
    // Retorna o nome da coluna do tipo detail
    // Retorna o nome da coluna do tipo detail
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getNameColumnDetail = 
    // Retorna o nome da coluna do tipo detail
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var detail = this.getColumnMasterDetail();
        return detail ? detail.property : null;
    };
    /**
     * Retorna as linhas do `thf-table` que estão selecionadas.
     */
    /**
     * Retorna as linhas do `thf-table` que estão selecionadas.
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getSelectedRows = /**
     * Retorna as linhas do `thf-table` que estão selecionadas.
     * @return {?}
     */
    function () {
        return this.items.filter(function (item) { return item.$selected; });
    };
    /**
     * Retorna as linhas do `thf-table` que não estão selecionadas.
     */
    /**
     * Retorna as linhas do `thf-table` que não estão selecionadas.
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getUnselectedRows = /**
     * Retorna as linhas do `thf-table` que não estão selecionadas.
     * @return {?}
     */
    function () {
        return this.items.filter(function (item) { return !item.$selected; });
    };
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.hasColumns = /**
     * @return {?}
     */
    function () {
        return this.columns && this.columns.length > 0;
    };
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.hasItems = /**
     * @return {?}
     */
    function () {
        return this.items && this.items.length > 0;
    };
    /**
     * @param {?} row
     * @return {?}
     */
    ThfTableBaseComponent.prototype.toggleRowAction = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        /** @type {?} */
        var toggleShowAction = row.$showAction;
        this.items.forEach(function (item) {
            if (item.$showAction) {
                item.$showAction = false;
            }
        });
        row.$showAction = !toggleShowAction;
    };
    /**
     * @param {?} column
     * @return {?}
     */
    ThfTableBaseComponent.prototype.sortColumn = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        if (!this.sort || column.type === 'detail') {
            return;
        }
        this.sortedColumn.ascending = this.sortedColumn.property === column ? !this.sortedColumn.ascending : true;
        this.sortArray(column, this.sortedColumn.ascending);
        this.sortedColumn.property = column;
    };
    /**
     * @param {?} column
     * @param {?} ascending
     * @return {?}
     */
    ThfTableBaseComponent.prototype.sortArray = /**
     * @param {?} column
     * @param {?} ascending
     * @return {?}
     */
    function (column, ascending) {
        var _this = this;
        this.items.sort(function (leftSide, rightSide) {
            if (column.type === 'date' || column.type === 'dateTime') {
                return _this.thfDate.sortDate(leftSide[column.property], rightSide[column.property], ascending);
            }
            else {
                return sortValues(leftSide[column.property], rightSide[column.property], ascending);
            }
        });
    };
    /**
     * @return {?}
     */
    ThfTableBaseComponent.prototype.onShowMore = /**
     * @return {?}
     */
    function () {
        this.showMore.emit(null);
    };
    /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    ThfTableBaseComponent.prototype.getDefaultColumns = /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var keys = Object.keys(item);
        return keys.filter(function (key) { return (typeof item[key] !== 'object'); }).map(function (key) {
            return { label: capitalizeFirstLetter(key), property: key };
        });
    };
    /**
     * @private
     * @param {?} rows
     * @param {?} row
     * @return {?}
     */
    ThfTableBaseComponent.prototype.configAfterSelectRow = /**
     * @private
     * @param {?} rows
     * @param {?} row
     * @return {?}
     */
    function (rows, row) {
        if (this.singleSelect) {
            this.unselectOtherRows(rows, row);
        }
        else if (!this.hideSelectAll) {
            this.selectAll = this.isEverySelected(rows);
        }
    };
    /**
     * @private
     * @param {?} selectAll
     * @param {?} rows
     * @return {?}
     */
    ThfTableBaseComponent.prototype.emitSelectAllEvents = /**
     * @private
     * @param {?} selectAll
     * @param {?} rows
     * @return {?}
     */
    function (selectAll, rows) {
        selectAll ? this.allSelected.emit(rows) : this.allUnselected.emit(rows);
    };
    /**
     * @private
     * @param {?} row
     * @return {?}
     */
    ThfTableBaseComponent.prototype.emitSelectEvents = /**
     * @private
     * @param {?} row
     * @return {?}
     */
    function (row) {
        row.$selected ? this.selected.emit(row) : this.unselected.emit(row);
    };
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    ThfTableBaseComponent.prototype.isEverySelected = /**
     * @private
     * @param {?} items
     * @return {?}
     */
    function (items) {
        /** @type {?} */
        var someCheckedOrIndeterminate = function (item) { return item.$selected || item.$selected === null; };
        /** @type {?} */
        var everyChecked = function (item) { return item.$selected; };
        if (items.every(everyChecked)) {
            return true;
        }
        if (items.some(someCheckedOrIndeterminate)) {
            return null;
        }
        return false;
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableBaseComponent.prototype.mapColumnToProperty = /**
     * @private
     * @return {?}
     */
    function () {
        this._columns.forEach(function (column) { return column.property = column.property || column.column; });
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableBaseComponent.prototype.setColumnLink = /**
     * @private
     * @return {?}
     */
    function () {
        this.columns.forEach(function (column) {
            if (column['type'] === 'link' && !column['link']) {
                column['link'] = 'link';
            }
        });
    };
    /**
     * @private
     * @param {?} rows
     * @param {?} row
     * @return {?}
     */
    ThfTableBaseComponent.prototype.unselectOtherRows = /**
     * @private
     * @param {?} rows
     * @param {?} row
     * @return {?}
     */
    function (rows, row) {
        rows.forEach(function (item) {
            if (item !== row) {
                item.$selected = false;
            }
        });
    };
    ThfTableBaseComponent.propDecorators = {
        items: [{ type: core.Input, args: ['t-items',] }],
        columns: [{ type: core.Input, args: ['t-columns',] }],
        container: [{ type: core.Input, args: ['t-container',] }],
        hideTextOverflow: [{ type: core.Input, args: ['t-hide-text-overflow',] }],
        height: [{ type: core.Input, args: ['t-height',] }],
        hideDetail: [{ type: core.Input, args: ['t-hide-detail',] }],
        literals: [{ type: core.Input, args: ['t-literals',] }],
        loading: [{ type: core.Input, args: ['t-loading',] }],
        checkbox: [{ type: core.Input, args: ['t-checkbox',] }],
        actions: [{ type: core.Input, args: ['t-actions',] }],
        setSort: [{ type: core.Input, args: ['t-sort',] }],
        setShowMoreDisabled: [{ type: core.Input, args: ['t-show-more-disabled',] }],
        setStriped: [{ type: core.Input, args: ['t-striped',] }],
        setHideSelectAll: [{ type: core.Input, args: ['t-hide-select-all',] }],
        setSingleSelect: [{ type: core.Input, args: ['t-single-select',] }],
        noData: [{ type: core.Input, args: ['t-no-data',] }],
        allSelected: [{ type: core.Output, args: ['t-all-selected',] }],
        allUnselected: [{ type: core.Output, args: ['t-all-unselected',] }],
        selected: [{ type: core.Output, args: ['t-selected',] }],
        showMore: [{ type: core.Output, args: ['t-show-more',] }],
        unselected: [{ type: core.Output, args: ['t-unselected',] }]
    };
    return ThfTableBaseComponent;
}());

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfTableBaseComponent
 *
 * \@example
 *
 * <example name="thf-table-basic" title="Totvs Table Basic">
 *  <file name="sample-thf-table-basic/sample-thf-table-basic.component.ts"> </file>
 *  <file name="sample-thf-table-basic/sample-thf-table-basic.component.html"> </file>
 * </example>
 *
 * <example name="thf-table-labs" title="Totvs Table Labs">
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.component.ts"> </file>
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.component.html"> </file>
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.component.po.ts"> </file>
 *  <file name="sample-thf-table-labs/sample-thf-table-labs.service.ts"> </file>
 * </example>
 *
 * <example name="thf-table-transport" title="Totvs Table - Transport">
 *  <file name="sample-thf-table-transport/sample-thf-table-transport.component.ts"> </file>
 *  <file name="sample-thf-table-transport/sample-thf-table-transport.component.html"> </file>
 *  <file name="sample-thf-table-transport/sample-thf-table-transport.service.ts"> </file>
 * </example>
 *
 * <example name="thf-table-airfare" title="Totvs Table - Airfare">
 *  <file name="sample-thf-table-airfare/sample-thf-table-airfare.component.ts"> </file>
 *  <file name="sample-thf-table-airfare/sample-thf-table-airfare.component.html"> </file>
 *  <file name="sample-thf-table-airfare/sample-thf-table-airfare.service.ts"> </file>
 * </example>
 *
 * <example name="thf-table-components" title="Totvs Table - Thf Field Components">
 *  <file name="sample-thf-table-components/sample-thf-table-components.component.ts"> </file>
 *  <file name="sample-thf-table-components/sample-thf-table-components.component.html"> </file>
 * </example>
 */
var ThfTableComponent = /** @class */ (function (_super) {
    __extends$1(ThfTableComponent, _super);
    function ThfTableComponent(thfDate, differs, viewRef, renderer, changeDetector, decimalPipe, router$$1) {
        var _this = _super.call(this, thfDate) || this;
        _this.changeDetector = changeDetector;
        _this.decimalPipe = decimalPipe;
        _this.router = router$$1;
        _this.tableOpacity = 0;
        _this.initialized = false;
        _this.visibleElement = false;
        _this.parentRef = viewRef['_view']['component'];
        _this.differ = differs.find([]).create(null);
        // TODO: #5550 ao remover este listener, no portal, quando as colunas forem fixas não sofrem
        // alteração de largura, pois o ngDoCheck não é executado.
        _this.clickListener = renderer.listen('document', 'click', function () { });
        _this.resizeListener = renderer.listen('window', 'resize', function (event) {
            _this.debounceResize();
        });
        return _this;
    }
    Object.defineProperty(ThfTableComponent.prototype, "detailHideSelect", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var masterDetail = this.getColumnMasterDetail();
            return masterDetail && masterDetail.detail ? masterDetail.detail.hideSelect : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableComponent.prototype, "firstAction", {
        get: /**
         * @return {?}
         */
        function () {
            return this.visibleActions && this.visibleActions[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableComponent.prototype, "hasRowTemplate", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.tableRowTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableComponent.prototype, "visibleActions", {
        get: /**
         * @return {?}
         */
        function () {
            return this.actions && this.actions.filter(function (action) { return action.visible !== false; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.initialized = true;
        if (!this.container) {
            this.hideContainer();
        }
    };
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        this.checkChangesItems();
        this.verifyCalculateHeightTableContainer();
        // Permite que os cabeçalhos sejam calculados na primeira vez que o componente torna-se visível,
        // evitando com isso, problemas com Tabs ou Divs que iniciem escondidas.
        if (this.tableWrapperElement.nativeElement.offsetWidth && !this.visibleElement && this.initialized) {
            this.debounceResize();
            this.visibleElement = true;
        }
    };
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeListeners();
    };
    /**
     * @param {?} row
     * @param {?} tableAction
     * @return {?}
     */
    ThfTableComponent.prototype.executeTableAction = /**
     * @param {?} row
     * @param {?} tableAction
     * @return {?}
     */
    function (row, tableAction) {
        if (!row.disabled && !this.validateTableAction(row, tableAction)) {
            if (typeof tableAction.action === 'string') {
                this.parentRef[tableAction.action](row);
            }
            else {
                tableAction.action.call(this.parentRef, row);
            }
            this.toggleRowAction(row);
        }
    };
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.columnCountForMasterDetail = /**
     * @return {?}
     */
    function () {
        return (this.getMainColumns().length + 1) + (this.actions.length > 0 ? 1 : 0) + (this.checkbox ? 1 : 0);
    };
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.columnCount = /**
     * @return {?}
     */
    function () {
        return (this.getMainColumns().length +
            (this.actions.length > 0 ? 1 : 0) +
            (this.checkbox ? 1 : 0) +
            (!this.hideDetail && this.getColumnMasterDetail() !== undefined ? 1 : 0));
    };
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    ThfTableComponent.prototype.formatNumber = /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    function (value, format) {
        if (!format) {
            return value;
        }
        return this.decimalPipe.transform(value, format);
    };
    /**
     * @param {?} row
     * @param {?} subtitleColumn
     * @return {?}
     */
    ThfTableComponent.prototype.getSubtitleColumn = /**
     * @param {?} row
     * @param {?} subtitleColumn
     * @return {?}
     */
    function (row, subtitleColumn) {
        return subtitleColumn.subtitles.find(function (subtitleItem) { return row[subtitleColumn.property] === subtitleItem.value; });
    };
    /**
     * @param {?} rowValue
     * @param {?} columnBoolean
     * @return {?}
     */
    ThfTableComponent.prototype.getBooleanLabel = /**
     * @param {?} rowValue
     * @param {?} columnBoolean
     * @return {?}
     */
    function (rowValue, columnBoolean) {
        if (rowValue || rowValue === false || rowValue === 0) {
            rowValue = convertToBoolean(rowValue);
            if (columnBoolean.boolean) {
                return rowValue ? columnBoolean.boolean.trueLabel || 'Sim' : columnBoolean.boolean.falseLabel || 'Não';
            }
            else {
                return rowValue ? 'Sim' : 'Não';
            }
        }
        return rowValue;
    };
    /**
     * @param {?} row
     * @param {?} columnIcon
     * @return {?}
     */
    ThfTableComponent.prototype.getColumnIcons = /**
     * @param {?} row
     * @param {?} columnIcon
     * @return {?}
     */
    function (row, columnIcon) {
        /** @type {?} */
        var columnValues = row[columnIcon.property];
        if (columnIcon.icons) {
            if (columnValues instanceof Array) {
                return this.mergeCustomIcons(columnValues, columnIcon.icons);
            }
            if (typeof columnValues === 'string') {
                /** @type {?} */
                var customIcon = columnIcon.icons.find(function (icon) { return columnValues === icon.value; });
                if (customIcon) {
                    return [customIcon];
                }
            }
        }
        return columnValues;
    };
    /**
     * @param {?} row
     * @param {?} columnLabel
     * @return {?}
     */
    ThfTableComponent.prototype.getColumnLabel = /**
     * @param {?} row
     * @param {?} columnLabel
     * @return {?}
     */
    function (row, columnLabel) {
        return columnLabel.labels.find(function (labelItem) { return row[columnLabel.property] === labelItem.value; });
    };
    /**
     * @param {?} column
     * @return {?}
     */
    ThfTableComponent.prototype.getColumnTitleLabel = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return column.label || capitalizeFirstLetter(column.property);
    };
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.verifyWidthColumnsPixels = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var columns = this.getMainColumns();
        return columns.length ? columns.every(function (column) { return column.width && column.width.includes('px'); }) : false;
    };
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.calculateWidthHeaders = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            if (_this.height) {
                _this.headersTable.forEach(function (header) {
                    /** @type {?} */
                    var divHeader = header.nativeElement.querySelector('.thf-table-header-fixed-inner');
                    if (divHeader) {
                        divHeader.style.width = header.nativeElement.offsetWidth + "px";
                    }
                });
            }
        });
    };
    /**
     * @param {?} row
     * @return {?}
     */
    ThfTableComponent.prototype.containsMasterDetail = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        return row[this.getNameColumnDetail()] && row[this.getNameColumnDetail()].length;
    };
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    ThfTableComponent.prototype.isShowRowTemplate = /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    function (row, index) {
        if (this.tableRowTemplate && this.tableRowTemplate.thfTableRowTemplateShow) {
            return this.tableRowTemplate.thfTableRowTemplateShow(row, index);
        }
        return true;
    };
    /**
     * @param {?} row
     * @return {?}
     */
    ThfTableComponent.prototype.isShowMasterDetail = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        return !this.hideDetail &&
            this.getNameColumnDetail() &&
            row.$showDetail &&
            this.containsMasterDetail(row) &&
            !this.hasRowTemplate;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ThfTableComponent.prototype.tooltipMouseEnter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.tooltipText = undefined;
        if (this.hideTextOverflow &&
            event.target.offsetWidth < event.target.scrollWidth &&
            event.target.innerText.trim()) {
            this.tooltipText = event.target.innerText;
        }
    };
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.tooltipMouseLeave = /**
     * @return {?}
     */
    function () {
        this.tooltipText = undefined;
    };
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.verifyChangeHeightInFooter = /**
     * @return {?}
     */
    function () {
        return this.footerHeight !== this.getHeightTableFooter();
    };
    /**
     * @return {?}
     */
    ThfTableComponent.prototype.verifyCalculateHeightTableContainer = /**
     * @return {?}
     */
    function () {
        if (this.height && this.verifyChangeHeightInFooter()) {
            this.footerHeight = this.getHeightTableFooter();
            this.calculateHeightTableContainer(this.height);
        }
    };
    /**
     * @param {?} height
     * @return {?}
     */
    ThfTableComponent.prototype.calculateHeightTableContainer = /**
     * @param {?} height
     * @return {?}
     */
    function (height) {
        /** @type {?} */
        var value = parseFloat(height);
        this.heightTableContainer = value ? (value - this.getHeightTableFooter()) : undefined;
        this.setTableOpacity(1);
        this.changeDetector.detectChanges();
    };
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    ThfTableComponent.prototype.getTypeColumnLink = /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    function (row, column) {
        /** @type {?} */
        var rowLink;
        if (column.action) {
            return 'action';
        }
        rowLink = row[column.link];
        if (rowLink && rowLink.startsWith('http')) {
            return 'externalLink';
        }
        return 'internalLink';
    };
    /**
     * @param {?} row
     * @param {?} targetRef
     * @return {?}
     */
    ThfTableComponent.prototype.togglePopup = /**
     * @param {?} row
     * @param {?} targetRef
     * @return {?}
     */
    function (row, targetRef) {
        this.popupTarget = targetRef;
        this.changeDetector.detectChanges();
        this.thfPopupComponent.toggle(row);
    };
    /**
     * @protected
     * @param {?} container
     * @return {?}
     */
    ThfTableComponent.prototype.showContainer = /**
     * @protected
     * @param {?} container
     * @return {?}
     */
    function (container) {
        /** @type {?} */
        var containerClassList = this.tableContainerElement.nativeElement.firstChild.classList;
        containerClassList.add('thf-container');
        container === 'border' ? containerClassList.add('thf-container-no-shadow') : containerClassList.remove('thf-container-no-shadow');
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableComponent.prototype.checkChangesItems = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var changesItems = this.differ.diff(this.items);
        if (changesItems && this.selectAll) {
            this.selectAll = null;
        }
        if (changesItems && !this.hasColumns() && this.hasItems()) {
            this.columns = this.getDefaultColumns(this.items[0]);
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableComponent.prototype.getHeightTableFooter = /**
     * @private
     * @return {?}
     */
    function () {
        return this.tableFooterElement ? this.tableFooterElement.nativeElement.offsetHeight : 0;
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableComponent.prototype.hideContainer = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var containerClassList = this.tableContainerElement.nativeElement.firstChild.classList;
        containerClassList.remove('thf-container');
    };
    /**
     * @private
     * @param {?} columnValues
     * @param {?} customIcons
     * @return {?}
     */
    ThfTableComponent.prototype.mergeCustomIcons = /**
     * @private
     * @param {?} columnValues
     * @param {?} customIcons
     * @return {?}
     */
    function (columnValues, customIcons) {
        /** @type {?} */
        var icons = [];
        columnValues.forEach(function (columnValue) {
            /** @type {?} */
            var foundCustomIcon = customIcons.find(function (customIcon) { return columnValue === customIcon.icon || columnValue === customIcon.value; });
            foundCustomIcon ? icons.push(foundCustomIcon) : icons.push(columnValue);
        });
        return icons;
    };
    /**
     * @private
     * @param {?} row
     * @param {?} tableAction
     * @return {?}
     */
    ThfTableComponent.prototype.validateTableAction = /**
     * @private
     * @param {?} row
     * @param {?} tableAction
     * @return {?}
     */
    function (row, tableAction) {
        if (typeof tableAction.disabled === 'function') {
            return tableAction.disabled.call(this.parentRef, row);
        }
        else {
            return tableAction.disabled;
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableComponent.prototype.debounceResize = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        clearTimeout(this.timeoutResize);
        this.timeoutResize = setTimeout(function () {
            _this.calculateWidthHeaders();
            // show the table
            _this.setTableOpacity(1);
        });
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableComponent.prototype.removeListeners = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.resizeListener) {
            this.resizeListener();
        }
        if (this.clickListener) {
            this.clickListener();
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    ThfTableComponent.prototype.setTableOpacity = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.tableOpacity = value;
    };
    ThfTableComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-table', template: "<thf-container #tableContainer t-no-padding> <div [class.thf-table-container-relative]=\"loading\"> <div *ngIf=\"loading\" class=\"thf-table-overlay\"> <thf-loading class=\"thf-table-overlay-content\" [t-text]=\"literals.loadingData\"></thf-loading> </div> <div class=\"thf-table-main-container\"> <div #tableWrapper class=\"thf-table-wrapper\" [class.thf-table-header-fixed-columns-pixels]=\"verifyWidthColumnsPixels()\" [style.opacity]=\"tableOpacity\"> <div class=\"thf-table-container\" *ngIf=\"height\" [style.height.px]=\"heightTableContainer\"> <div class=\"thf-table-header-fixed thf-table-header\"></div> <div class=\"thf-table-container-fixed-inner\"> <ng-container *ngTemplateOutlet=\"tableTemplate\"></ng-container> </div> </div> <div *ngIf=\"!height\"> <ng-container *ngTemplateOutlet=\"tableTemplate\"></ng-container> </div> </div> </div> </div> <div class=\"thf-table-footer\" *ngIf=\"hasItems() && getSubtitleColumns().length\"> <div *ngFor=\"let column of getSubtitleColumns()\"> <thf-table-subtitle-footer [t-literals]=\"literals\" [t-subtitles]=\"column.subtitles\"></thf-table-subtitle-footer> </div> </div> </thf-container> <div class=\"thf-row thf-table-footer-show-more\" [class.thf-invisible]=\"showMore.observers.length === 0\" #tableFooter> <thf-button class=\"thf-offset-xl-4 thf-offset-lg-4 thf-offset-md-3 thf-lg-4 thf-md-6\" [t-disabled]=\"showMoreDisabled\" [t-label]=\"literals.loadMoreData\" (t-click)=\"onShowMore()\"> </thf-button> </div> <ng-template #tableTemplate> <table class=\"thf-table\" [class.thf-table-striped]=\"striped\" [class.thf-table-layout-fixed]=\"hideTextOverflow\"> <thead> <tr [class.thf-table-header]=\"!height\"> <th *ngIf=\"checkbox && hasItems()\" class=\"thf-table-column-checkbox\"> <div [class.thf-table-header-fixed-inner]=\"height\"> <input *ngIf=\"!hideSelectAll\" type=\"checkbox\" class=\"thf-table-checkbox\" [class.thf-table-checkbox-checked]=\"selectAll\" [class.thf-table-checkbox-indeterminate]=\"selectAll === null\"> <label *ngIf=\"!hideSelectAll\" class=\"thf-table-checkbox-label thf-clickable\" (click)=\"selectAllRows()\"></label> </div> </th> <th *ngIf=\"hasItems() && !hideDetail && getColumnMasterDetail() !== undefined || hasRowTemplate\" class=\"thf-table-header-column thf-table-header-master-detail\"> </th> <th *ngIf=\"!hasColumns()\" class=\"thf-table-header-column thf-text-center\">{{ literals.noColumns }}</th> <th *ngFor=\"let column of getMainColumns(); let i = index\" #headersTable class=\"thf-table-header-ellipsis\" [style.width]=\"column.width\" [style.max-width]=\"column.width\" [style.min-width]=\"column.width\" [class.thf-clickable]=\"sort\" [class.thf-table-column-right]= \"column.type === 'currency' || column.type === 'number'\" [class.thf-table-header-subtitle]=\"column.type === 'subtitle'\" (click)=\"sortColumn(column)\"> <div *ngIf=\"height\" class=\"thf-table-header-fixed-inner\"> <ng-container *ngTemplateOutlet=\"contentHeaderTemplate\"></ng-container> </div> <div *ngIf=\"!height\"> <ng-container *ngTemplateOutlet=\"contentHeaderTemplate\"></ng-container> </div> <ng-template #contentHeaderTemplate> <span *ngIf=\"sort\" [class.thf-table-header-icon-unselected]= \"sortedColumn?.property !== column\" [class.thf-table-header-icon-descending]= \"sortedColumn?.property === column && sortedColumn.ascending\" [class.thf-table-header-icon-ascending]= \"sortedColumn?.property === column && !sortedColumn.ascending\"> </span> <span class=\"thf-table-header-ellipsis thf-table-header-block\" [t-tooltip]=\"tooltipText\" (mouseenter)=\"tooltipMouseEnter($event)\" (mouseleave)=\"tooltipMouseLeave()\"> {{ getColumnTitleLabel(column) }} </span> </ng-template> </th> <th *ngIf=\"visibleActions.length > 1 && hasItems()\" class=\"thf-table-header-action\"></th> <th *ngIf=\"visibleActions.length === 1 && hasItems()\" class=\"thf-table-header-single-action\"></th> </tr> </thead> <tbody class=\"thf-table-group-row\" *ngIf=\"!hasItems()\"> <tr class=\"thf-table-row\"> <td [colSpan]=\"columnCount()\" class=\"thf-table-no-data thf-text-center\"> <span> {{ literals.noData }} </span> </td> </tr> </tbody> <tbody class=\"thf-table-group-row\" *ngFor=\"let row of items, let rowIndex = index;\"> <tr class=\"thf-table-row\" [class.thf-table-row-active]=\"row.$selected || row.$selected === null && checkbox\"> <td *ngIf=\"checkbox\" class=\"thf-table-column thf-table-column-checkbox\"> <ng-container *ngIf=\"singleSelect; then inputRadio; else inputCheckbox\"> </ng-container> <ng-template #inputRadio> <input type=\"radio\" class=\"thf-radio-group-input\" [class.thf-radio-group-input-checked]=\"row.$selected\"> <label class=\"thf-radio-group-label thf-clickable\" (click)=\"checkbox ? selectRow(row) : 'javascript:;'\"></label> </ng-template> <ng-template #inputCheckbox> <input type=\"checkbox\" class=\"thf-table-checkbox\" [class.thf-table-checkbox-checked]=\"row.$selected\"> <label class=\"thf-table-checkbox-label thf-clickable\" (click)=\"checkbox ? selectRow(row) : 'javascript:;'\"></label> </ng-template> </td> <td *ngIf=\"(getColumnMasterDetail() !== undefined) && !hideDetail || hasRowTemplate\" (click)=\"row.$showDetail = !row.$showDetail\" class=\"thf-table-column-detail-toggle\"> <span *ngIf=\"(containsMasterDetail(row) && !hasRowTemplate) || isShowRowTemplate(row, rowIndex) && hasRowTemplate\" [class.thf-icon-arrow-up]=\"row.$showDetail\" [class.thf-icon-arrow-down]=\"!row.$showDetail\" class=\"thf-icon thf-clickable\"> </span> </td> <td *ngFor=\"let column of getMainColumns(), let columnIndex = index;\" [style.width]=\"column.width\" [style.max-width]=\"column.width\" [style.min-width]=\"column.width\" [class.thf-table-column]=\"column.type !== 'icon'\" [class.thf-table-column-right]=\"column.type == 'currency' || column.type == 'number'\" [class.thf-table-column-center]=\"column.type === 'subtitle'\" [class.thf-table-column-icons]=\"column.type === 'icon'\" [ngClass]=\"getClassColor(row, column)\" (click)=\"checkbox ? selectRow(row) : 'javascript:;'\"> <div [class.thf-table-body-ellipsis]=\"hideTextOverflow\" [ngSwitch]=\"column.type\" [t-tooltip]=\"tooltipText\" (mouseenter)=\"tooltipMouseEnter($event)\" (mouseleave)=\"tooltipMouseLeave()\"> <span *ngSwitchCase=\"'boolean'\">{{ getBooleanLabel(row[column.property], column) }}</span> <span *ngSwitchCase=\"'currency'\">{{ row[column.property] | currency:column.format:'symbol':'1.2-2' }}</span> <span *ngSwitchCase=\"'date'\" >{{ row[column.property] | date: column.format || 'dd/MM/yyyy' }}</span> <span *ngSwitchCase=\"'time'\" >{{ row[column.property] | thf_time: column.format || 'HH:mm:ss.ffffff' }}</span> <span *ngSwitchCase=\"'dateTime'\" >{{ row[column.property] | date: column.format || 'dd/MM/yyyy HH:mm:ss' }}</span> <span *ngSwitchCase=\"'number'\">{{ formatNumber(row[column.property], column.format) }}</span> <span *ngSwitchCase=\"'link'\"> <a class=\"thf-table-link\" *ngIf=\"getTypeColumnLink(row, column) === 'action'\" (click)='column.action(row[column.property], row)'> {{ row[column.property] }} </a> <a class=\"thf-table-link\" *ngIf=\"getTypeColumnLink(row, column) === 'externalLink'\" [href]=\"row[column.link]\" target=\"_blank\"> {{ row[column.property] }} </a> <a class=\"thf-table-link\" *ngIf=\"getTypeColumnLink(row, column) === 'internalLink'\" [routerLink]=\"row[column.link]\"> {{ row[column.property] }} </a> </span> <span *ngSwitchCase=\"'icon'\"> <thf-table-column-icon [t-icons]=\"getColumnIcons(row, column)\" [t-column]=\"column\" [t-row]=\"row\"> </thf-table-column-icon> </span> <span *ngSwitchCase=\"'subtitle'\"> <thf-table-subtitle-circle [t-subtitle]=\"getSubtitleColumn(row, column)\"></thf-table-subtitle-circle> </span> <span *ngSwitchCase=\"'label'\"> <thf-table-column-label [t-value]=\"getColumnLabel(row, column)\"></thf-table-column-label> </span> <span *ngSwitchDefault>{{ row[column.property] }}</span> </div> </td> <td *ngIf=\"visibleActions.length === 1\" class=\"thf-table-column thf-table-column-single-action\"> <div *ngIf=\"firstAction.visible !== false\" class=\"thf-table-single-action thf-clickable\" [class.thf-table-action-disabled]= \"firstAction.disabled ? validateTableAction(row, firstAction) : false\" (click)=\"executeTableAction(row, firstAction)\"> <span *ngIf=\"firstAction.icon\" class=\"thf-icon {{ firstAction.icon }}\"></span> {{ firstAction.label }} </div> </td> <td *ngIf=\"visibleActions.length > 1\" class=\"thf-table-column-actions\"> <span #popupTarget class=\"thf-icon thf-icon-more thf-clickable\" (click)=\"togglePopup(row, popupTarget)\"> </span> </td> </tr> <tr *ngIf=\"hasRowTemplate && row.$showDetail && isShowRowTemplate(row, rowIndex)\"> <td class=\"thf-table-row-template-container\" [colSpan]=\"columnCountForMasterDetail()\"> <ng-template [ngTemplateOutlet]=\"tableRowTemplate.templateRef\" [ngTemplateOutletContext]=\"{ $implicit: row, rowIndex: rowIndex }\"> </ng-template> </td> </tr> <tr *ngIf=\"isShowMasterDetail(row)\"> <td class=\"thf-table-column-detail\" [colSpan]=\"columnCountForMasterDetail()\"> <thf-table-detail [t-checkbox]=\"checkbox && !detailHideSelect\" [t-detail]=\"getColumnMasterDetail().detail\" [t-items]=\"row[getNameColumnDetail()]\" (t-select-row)=\"selectDetailRow($event)\"> </thf-table-detail> </td> </tr> </tbody> </table> <thf-popup #popup [t-actions]=\"actions\" [t-target]=\"popupTarget\"> </thf-popup> </ng-template> ",
                    providers: [ThfDateService]
                },] },
    ];
    /** @nocollapse */
    ThfTableComponent.ctorParameters = function () { return [
        { type: ThfDateService },
        { type: core.IterableDiffers },
        { type: core.ViewContainerRef },
        { type: core.Renderer2 },
        { type: core.ChangeDetectorRef },
        { type: common.DecimalPipe },
        { type: router.Router }
    ]; };
    ThfTableComponent.propDecorators = {
        tableRowTemplate: [{ type: core.ContentChild, args: [ThfTableRowTemplateDirective,] }],
        thfPopupComponent: [{ type: core.ViewChild, args: ['popup',] }],
        tableContainerElement: [{ type: core.ViewChild, args: ['tableContainer', { read: core.ElementRef },] }],
        tableFooterElement: [{ type: core.ViewChild, args: ['tableFooter', { read: core.ElementRef },] }],
        tableWrapperElement: [{ type: core.ViewChild, args: ['tableWrapper', { read: core.ElementRef },] }],
        actionsIconElement: [{ type: core.ViewChildren, args: ['actionsIconElement', { read: core.ElementRef },] }],
        actionsElement: [{ type: core.ViewChildren, args: ['actionsElement', { read: core.ElementRef },] }],
        headersTable: [{ type: core.ViewChildren, args: ['headersTable',] }]
    };
    return ThfTableComponent;
}(ThfTableBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var THF_BUTTON_TYPES = ['default', 'primary', 'danger', 'link'];
/** @type {?} */
var THF_BUTTON_TYPE_DEFAULT = 'default';
/**
 * \@description
 *
 * O `thf-button` permite que o usuário execute ações predefinidas pelo desenvolvedor.
 *
 * Através dos tipos, é possível identificar a importância de cada ação, sendo ela primária (`primary`) ou até mesmo uma
 * ação irreversível (`danger`), como a exclusão de um registro.
 *
 * #### Boas práticas
 *
 * - Evite `labels` extensos que quebram o layout do `thf-button`, use `labels` diretos, curtos e intuitivos.
 * - Utilize apenas um `thf-button` configurado como `primary` por página.
 * - Para ações irreversíveis use sempre o tipo `danger`.
 */
var ThfButtonBaseComponent = /** @class */ (function () {
    function ThfButtonBaseComponent() {
        this._disabled = false;
        this._loading = false;
        this._small = false;
        this._type = 'default';
        /**
         * Ação que será executada quando o usuário clicar sobre o `thf-button`.
         */
        this.click = new core.EventEmitter();
    }
    Object.defineProperty(ThfButtonBaseComponent.prototype, "loading", {
        get: /**
         * @return {?}
         */
        function () {
            return this._loading;
        },
        /**
         * @optional
         *
         * @description
         *
         * Exibe um ícone de carregamento à esquerda do _label_ do botão.
         *
         * > Quando esta propriedade estiver habilitada, desabilitará o botão.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Exibe um ícone de carregamento à esquerda do _label_ do botão.
         *
         * > Quando esta propriedade estiver habilitada, desabilitará o botão.
         *
         * \@default `false`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._loading = convertToBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfButtonBaseComponent.prototype, "small", {
        get: /**
         * @return {?}
         */
        function () {
            return this._small;
        },
        /**
         * @optional
         *
         * @description
         *
         * Deixa o botão menor.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Deixa o botão menor.
         *
         * \@default `false`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._small = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfButtonBaseComponent.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            return this._type;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define o estilo do `thf-button`.
         *
         * Valore válidos:
         *  - `default`: estilo padrão do `thf-button`.
         *  - `primary`: deixa o `thf-button` com destaque, deve ser usado para ações primárias.
         *  - `danger`: deve ser usado para ações que o usuário precisa ter cuidado ao executa-lá.
         *  - `link`: o `thf-button` recebe o estilo de um link.
         *
         * @default `default`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define o estilo do `thf-button`.
         *
         * Valore válidos:
         *  - `default`: estilo padrão do `thf-button`.
         *  - `primary`: deixa o `thf-button` com destaque, deve ser usado para ações primárias.
         *  - `danger`: deve ser usado para ações que o usuário precisa ter cuidado ao executa-lá.
         *  - `link`: o `thf-button` recebe o estilo de um link.
         *
         * \@default `default`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._type = THF_BUTTON_TYPES.includes(value) ? value : THF_BUTTON_TYPE_DEFAULT;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfButtonBaseComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        /**
         * @optional
         *
         * @description
         *
         * Desabilita o `thf-button` e não permite que o usuário interaja com o mesmo.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Desabilita o `thf-button` e não permite que o usuário interaja com o mesmo.
         *
         * \@default `false`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = (/** @type {?} */ (value)) === '' ? true : convertToBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    ThfButtonBaseComponent.propDecorators = {
        label: [{ type: core.Input, args: ['t-label',] }],
        loading: [{ type: core.Input, args: ['t-loading',] }],
        icon: [{ type: core.Input, args: ['t-icon',] }],
        small: [{ type: core.Input, args: ['t-small',] }],
        type: [{ type: core.Input, args: ['t-type',] }],
        disabled: [{ type: core.Input, args: ['t-disabled',] }],
        click: [{ type: core.Output, args: ['t-click',] }]
    };
    return ThfButtonBaseComponent;
}());

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfButtonBaseComponent
 *
 * \@example
 *
 * <example name="thf-button-basic" title="Totvs Button Basic">
 *  <file name="sample-thf-button-basic/sample-thf-button-basic.component.html"> </file>
 *  <file name="sample-thf-button-basic/sample-thf-button-basic.component.ts"> </file>
 *  <file name="sample-thf-button-basic/sample-thf-button-basic.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-button-basic/sample-thf-button-basic.component.po.ts"> </file>
 * </example>
 *
 * <example name="thf-button-labs" title="Totvs Button Labs">
 *  <file name="sample-thf-button-labs/sample-thf-button-labs.component.html"> </file>
 *  <file name="sample-thf-button-labs/sample-thf-button-labs.component.ts"> </file>
 *  <file name="sample-thf-button-labs/sample-thf-button-labs.component.e2e-spec.ts"> </file>
 *  <file name="sample-thf-button-labs/sample-thf-button-labs.component.po.ts"> </file>
 * </example>
 */
var ThfButtonComponent = /** @class */ (function (_super) {
    __extends$2(ThfButtonComponent, _super);
    function ThfButtonComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    ThfButtonComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.click.emit(null);
    };
    ThfButtonComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-button', template: "<button class=\"thf-button thf-text-ellipsis\" type=\"button\" [class.thf-button-danger]=\"type === 'danger'\" [class.thf-button-link]=\"type === 'link'\" [class.thf-button-primary]=\"type === 'primary'\" [class.thf-button-sm] = \"small\" [class.thf-clickable]=\"type === 'link'\" [disabled]=\"disabled || loading\" (click)=\"onClick()\"> <span *ngIf=\"loading\" class=\"thf-icon thf-button-loading-icon\"></span> <span *ngIf=\"icon\" class=\"thf-icon {{ icon }}\" aria-hidden=\"true\"></span> <span *ngIf=\"label\" class=\"thf-button-label\">{{ label }}</span> </button> "
                },] },
    ];
    return ThfButtonComponent;
}(ThfButtonBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-button.
 */
var ThfButtonModule = /** @class */ (function () {
    function ThfButtonModule() {
    }
    ThfButtonModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        ThfButtonComponent
                    ],
                    exports: [
                        ThfButtonComponent
                    ]
                },] },
    ];
    return ThfButtonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O `thf-container` é um componente que visa facilitar o agrupamento de conteúdos.
 * Por padrão o mesmo exibe um efeito de sombra ao seu redor e um espaçamento em sua parte interna, os quais podem ser
 * desabilitados. Além disso, sua altura acompanha a quantidade do conteúdo, porém pode ser fixada. Para controlar sua
 * largura, utilize o [Grid System](/guides/grid-system), assim possibilitando o tratamento para diferentes resoluções.
 */
var ThfContainerBaseComponent = /** @class */ (function () {
    function ThfContainerBaseComponent() {
        this._noPadding = false;
        this._noShadow = false;
    }
    Object.defineProperty(ThfContainerBaseComponent.prototype, "height", {
        get: /**
         * @return {?}
         */
        function () {
            return this._height;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define a altura do `thf-container`.
         *
         * > Caso não seja definido um valor, a altura se ajustará de acordo com o conteúdo.
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define a altura do `thf-container`.
         *
         * > Caso não seja definido um valor, a altura se ajustará de acordo com o conteúdo.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._height = convertToInt(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfContainerBaseComponent.prototype, "noPadding", {
        get: /**
         * @return {?}
         */
        function () {
            return this._noPadding;
        },
        /**
         * @optional
         *
         * @description
         *
         * Desabilita o espaçamento interno do `thf-container`.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Desabilita o espaçamento interno do `thf-container`.
         *
         * \@default `false`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._noPadding = convertToBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfContainerBaseComponent.prototype, "noShadow", {
        get: /**
         * @return {?}
         */
        function () {
            return this._noShadow;
        },
        /**
         * @optional
         *
         * @description
         *
         * Desabilita o sombreamento em torno do `thf-container`.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Desabilita o sombreamento em torno do `thf-container`.
         *
         * \@default `false`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._noShadow = convertToBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    ThfContainerBaseComponent.propDecorators = {
        height: [{ type: core.Input, args: ['t-height',] }],
        noPadding: [{ type: core.Input, args: ['t-no-padding',] }],
        noShadow: [{ type: core.Input, args: ['t-no-shadow',] }]
    };
    return ThfContainerBaseComponent;
}());

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfContainerBaseComponent
 *
 * \@example
 *
 * <example name="thf-container-basic" title="Totvs Container Basic">
 *  <file name="sample-thf-container-basic/sample-thf-container-basic.component.html"> </file>
 *  <file name="sample-thf-container-basic/sample-thf-container-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-container-labs" title="Totvs Container Labs">
 *  <file name="sample-thf-container-labs/sample-thf-container-labs.component.html"> </file>
 *  <file name="sample-thf-container-labs/sample-thf-container-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-container-dashboard" title="Totvs Container - Dashboard">
 *  <file name="sample-thf-container-dashboard/sample-thf-container-dashboard.component.html"> </file>
 *  <file name="sample-thf-container-dashboard/sample-thf-container-dashboard.component.ts"> </file>
 *  <file name="sample-thf-container-dashboard/sample-thf-container-dashboard.service.ts"> </file>
 * </example>
 */
var ThfContainerComponent = /** @class */ (function (_super) {
    __extends$3(ThfContainerComponent, _super);
    function ThfContainerComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ThfContainerComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-container', template: "<div class=\"thf-container\" [class.thf-container-no-padding]=\"noPadding\" [class.thf-container-no-shadow]=\"noShadow\" [style.height]=\"height ? height + 'px' : 'auto'\"> <ng-content></ng-content> </div> "
                },] },
    ];
    return ThfContainerComponent;
}(ThfContainerBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente `thf-container`.
 */
var ThfContainerModule = /** @class */ (function () {
    function ThfContainerModule() {
    }
    ThfContainerModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    exports: [
                        ThfContainerComponent
                    ],
                    declarations: [
                        ThfContainerComponent
                    ]
                },] },
    ];
    return ThfContainerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Este componente tem o objetivo de mostrar visualmente aos usuários que a aplicação está processando
 * ou aguardando a resposta de alguma requisição.
 */
var ThfLoadingBaseComponent = /** @class */ (function () {
    function ThfLoadingBaseComponent() {
        /**
         * Texto a ser exibido no componente.
         */
        this.text = 'Carregando';
    }
    ThfLoadingBaseComponent.propDecorators = {
        text: [{ type: core.Input, args: ['t-text',] }]
    };
    return ThfLoadingBaseComponent;
}());

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@docsExtends ThfLoadingBaseComponent
 */
var ThfLoadingComponent = /** @class */ (function (_super) {
    __extends$4(ThfLoadingComponent, _super);
    function ThfLoadingComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ThfLoadingComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-loading', template: "<div class=\"thf-loading\"> <span class=\"thf-loading-icon\"></span> <span class=\"thf-loading-label thf-text-ellipsis\" *ngIf=\"text\">{{text}}</span> </div> "
                },] },
    ];
    return ThfLoadingComponent;
}(ThfLoadingBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 *
 * Este componente mostra ao usuário uma imagem de _loading_ e bloqueia a página inteira ou o container escolhido,
 * enquanto aguarda a resposta de alguma requisição.
 */
var ThfLoadingOverlayBaseComponent = /** @class */ (function () {
    function ThfLoadingOverlayBaseComponent() {
        this._screenLock = false;
        /**
         * \@optional
         *
         * \@description
         *
         * Texto a ser exibido no componente.
         *
         * \@default `Carregando`
         */
        this.text = 'Carregando';
    }
    Object.defineProperty(ThfLoadingOverlayBaseComponent.prototype, "screenLock", {
        get: /**
         * @return {?}
         */
        function () {
            return this._screenLock;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define se o _overlay_ será aplicado a um container ou a página inteira.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define se o _overlay_ será aplicado a um container ou a página inteira.
         *
         * \@default `false`
         * @param {?} screenLock
         * @return {?}
         */
        function (screenLock) {
            this._screenLock = convertToBoolean(screenLock);
        },
        enumerable: true,
        configurable: true
    });
    ThfLoadingOverlayBaseComponent.propDecorators = {
        screenLock: [{ type: core.Input, args: ['t-screen-lock',] }],
        text: [{ type: core.Input, args: ['t-text',] }]
    };
    return ThfLoadingOverlayBaseComponent;
}());

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@docsExtends ThfLoadingOverlayBaseComponent
 *
 * \@example
 *
 * <example name="thf-loading-overlay-basic" title="Totvs Loading Overlay Basic">
 *  <file name="sample-thf-loading-overlay-basic/sample-thf-loading-overlay-basic.component.html"> </file>
 *  <file name="sample-thf-loading-overlay-basic/sample-thf-loading-overlay-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-loading-overlay-labs" title="Totvs Loading Overlay Labs">
 *  <file name="sample-thf-loading-overlay-labs/sample-thf-loading-overlay-labs.component.html"> </file>
 *  <file name="sample-thf-loading-overlay-labs/sample-thf-loading-overlay-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-loading-overlay-connection-test" title="Totvs Loading Overlay - Connection Test">
 *  <file name="sample-thf-loading-overlay-connection-test/sample-thf-loading-overlay-connection-test.component.html"> </file>
 *  <file name="sample-thf-loading-overlay-connection-test/sample-thf-loading-overlay-connection-test.component.ts"> </file>
 * </example>
 */
var ThfLoadingOverlayComponent = /** @class */ (function (_super) {
    __extends$5(ThfLoadingOverlayComponent, _super);
    function ThfLoadingOverlayComponent(changeDetector) {
        var _this = _super.call(this) || this;
        _this.changeDetector = changeDetector;
        return _this;
    }
    ThfLoadingOverlayComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-loading-overlay', template: "<div [class.thf-overlay-absolute]=\"!screenLock\" [class.thf-overlay-fixed]=\"screenLock\"> <thf-loading class=\"thf-loading-overlay-content\" [t-text]=\"text\"></thf-loading> </div> "
                },] },
    ];
    /** @nocollapse */
    ThfLoadingOverlayComponent.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef }
    ]; };
    return ThfLoadingOverlayComponent;
}(ThfLoadingOverlayBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 *
 * Módulo do componente thf-loading-overlay.
 */
var ThfLoadingModule = /** @class */ (function () {
    function ThfLoadingModule() {
    }
    ThfLoadingModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        ThfLoadingComponent,
                        ThfLoadingOverlayComponent
                    ],
                    exports: [
                        ThfLoadingComponent,
                        ThfLoadingOverlayComponent
                    ]
                },] },
    ];
    return ThfLoadingModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * O componente `thf-modal` é utilizado para incluir conteúdos rápidos e informativos.
 *
 * No cabeçalho do componente é possível definir um título e como também permite ocultar o ícone de fechamento da modal.
 *
 * Em seu corpo é possível definir um conteúdo informativo, podendo utilizar componentes como por exemplo `thf-chart`,
 * `thf-table` e os demais componentes do THF.
 *
 * No rodapé encontram-se os botões de ação primária e secundária, no qual permitem definir uma ação e um rótulo, bem como
 * definir um estado de carregando e / ou desabilitado. Também é possível definir o botão com o tipo *danger*.
 *
 * > É possível fechar a modal através da tecla *ESC*, quando a propriedade `t-hide-close` não estiver habilitada.
 */
var ThfModalBaseComponent = /** @class */ (function () {
    function ThfModalBaseComponent() {
        this._hideClose = false;
        this._size = 'md';
        /**
         * Define o fechamento da modal ao clicar fora da mesma.
         * Informe o valor `true` para ativar o fechamento ao clicar fora da modal.
         */
        this.clickOut = false;
        // Controla se a modal fica oculto ou visível, por padrão é oculto
        this.isHidden = true;
        // Event emmiter para quando a modal é fechada pelo 'X'.
        this.onXClosed = new core.EventEmitter();
    }
    Object.defineProperty(ThfModalBaseComponent.prototype, "size", {
        get: /**
         * @return {?}
         */
        function () {
            return this._size;
        },
        /**
         * Define o tamanho da modal.
         *
         * Valores válidos:
         *  - `sm` (pequeno)
         *  - `md` (médio)
         *  - `lg` (grande)
         *  - `xl` (extra grande)
         *  - `auto` (automático)
         *
         * > Quando informado `auto` a modal calculará automaticamente seu tamanho baseado em seu conteúdo.
         * Caso não seja informado um valor, a modal terá o tamanho definido como `md`.
         */
        set: /**
         * Define o tamanho da modal.
         *
         * Valores válidos:
         *  - `sm` (pequeno)
         *  - `md` (médio)
         *  - `lg` (grande)
         *  - `xl` (extra grande)
         *  - `auto` (automático)
         *
         * > Quando informado `auto` a modal calculará automaticamente seu tamanho baseado em seu conteúdo.
         * Caso não seja informado um valor, a modal terá o tamanho definido como `md`.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var sizes = ['sm', 'md', 'lg', 'xl', 'auto'];
            this._size = sizes.indexOf(value) > -1 ? value : 'md';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfModalBaseComponent.prototype, "setClickOut", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.clickOut = (value === '') ? false : convertToBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfModalBaseComponent.prototype, "hideClose", {
        get: /**
         * @return {?}
         */
        function () {
            return this._hideClose;
        },
        /**
         * @optional
         *
         * @description
         *
         * Oculta o ícone de fechar do cabeçalho da modal.
         *
         * > Caso a propriedade estiver habilitada, não será possível fechar a modal através da tecla *ESC*.
         *
         * @default `false`
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Oculta o ícone de fechar do cabeçalho da modal.
         *
         * > Caso a propriedade estiver habilitada, não será possível fechar a modal através da tecla *ESC*.
         *
         * \@default `false`
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hideClose = convertToBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    /** Função para fechar a modal. */
    /**
     * Função para fechar a modal.
     * @param {?=} xClosed
     * @return {?}
     */
    ThfModalBaseComponent.prototype.close = /**
     * Função para fechar a modal.
     * @param {?=} xClosed
     * @return {?}
     */
    function (xClosed) {
        if (xClosed === void 0) { xClosed = false; }
        this.isHidden = true;
        if (xClosed) {
            this.onXClosed.emit(xClosed);
        }
    };
    /** Função para abrir a modal. */
    /**
     * Função para abrir a modal.
     * @return {?}
     */
    ThfModalBaseComponent.prototype.open = /**
     * Função para abrir a modal.
     * @return {?}
     */
    function () {
        this.validPrimaryAction();
        this.isHidden = false;
    };
    /**
     * @return {?}
     */
    ThfModalBaseComponent.prototype.validPrimaryAction = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.primaryAction) {
            this.primaryAction = {
                action: function () { return _this.close(); },
                label: 'Ok',
            };
        }
        if (!this.primaryAction['action']) {
            this.primaryAction['action'] = function () { return _this.close(); };
        }
        if (!this.primaryAction['label']) {
            this.primaryAction['label'] = 'Ok';
        }
    };
    ThfModalBaseComponent.propDecorators = {
        title: [{ type: core.Input, args: ['t-title',] }],
        primaryAction: [{ type: core.Input, args: ['t-primary-action',] }],
        secondaryAction: [{ type: core.Input, args: ['t-secondary-action',] }],
        size: [{ type: core.Input, args: ['t-size',] }],
        setClickOut: [{ type: core.Input, args: ['t-click-out',] }],
        hideClose: [{ type: core.Input, args: ['t-hide-close',] }]
    };
    return ThfModalBaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ThfModalService = /** @class */ (function () {
    function ThfModalService() {
    }
    ThfModalService.decorators = [
        { type: core.Injectable },
    ];
    return ThfModalService;
}());

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfModalBaseComponent
 *
 * \@example
 *
 * <example name="thf-modal-basic" title="Totvs Modal Basic">
 *  <file name="sample-thf-modal-basic/sample-thf-modal-basic.component.html"> </file>
 *  <file name="sample-thf-modal-basic/sample-thf-modal-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-modal-labs" title="Totvs Modal Labs">
 *  <file name="sample-thf-modal-labs/sample-thf-modal-labs.component.html"> </file>
 *  <file name="sample-thf-modal-labs/sample-thf-modal-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-modal-fruits-salad" title="Totvs Modal - Fruits Salad">
 *  <file name="sample-thf-modal-fruits-salad/sample-thf-modal-fruits-salad.component.html"> </file>
 *  <file name="sample-thf-modal-fruits-salad/sample-thf-modal-fruits-salad.component.ts"> </file>
 * </example>
 */
var ThfModalComponent = /** @class */ (function (_super) {
    __extends$6(ThfModalComponent, _super);
    function ThfModalComponent(thfModalService) {
        var _this = _super.call(this) || this;
        _this.thfModalService = thfModalService;
        _this.focusableElements = 'input, select, textarea, button:not([disabled]), a';
        _this.id = uuid.v4();
        return _this;
    }
    /**
     * @param {?=} xClosed
     * @return {?}
     */
    ThfModalComponent.prototype.close = /**
     * @param {?=} xClosed
     * @return {?}
     */
    function (xClosed) {
        if (xClosed === void 0) { xClosed = false; }
        this.thfModalService.modalActive = undefined;
        _super.prototype.close.call(this, xClosed);
        document.removeEventListener('focus', this.focusFunction, true);
        if (this.sourceElement) {
            this.sourceElement.focus();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ThfModalComponent.prototype.closeModalOnEscapeKey = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.hideClose) {
            event.preventDefault();
            event.stopPropagation();
            this.close();
        }
    };
    /**
     * @return {?}
     */
    ThfModalComponent.prototype.getPrimaryActionButtonType = /**
     * @return {?}
     */
    function () {
        return this.primaryAction.danger ? 'danger' : 'primary';
    };
    /**
     * @return {?}
     */
    ThfModalComponent.prototype.getSecondaryActionButtonType = /**
     * @return {?}
     */
    function () {
        return this.secondaryAction && this.secondaryAction.danger && !this.primaryAction.danger ? 'danger' : 'default';
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ThfModalComponent.prototype.onClickOut = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.clickOut && !this.modalContent.nativeElement.contains(event.target)) {
            this.close();
        }
    };
    /**
     * @return {?}
     */
    ThfModalComponent.prototype.open = /**
     * @return {?}
     */
    function () {
        this.sourceElement = document.activeElement;
        _super.prototype.open.call(this);
        this.handleFocus();
    };
    /**
     * @private
     * @return {?}
     */
    ThfModalComponent.prototype.handleFocus = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.thfModalService.modalActive = this.id;
        setTimeout(function () {
            if (_this.modalContent) {
                _this.initFocus();
                document.addEventListener('focus', _this.focusFunction, true);
            }
        });
    };
    /**
     * @private
     * @return {?}
     */
    ThfModalComponent.prototype.initFocus = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.focusFunction = function (event) {
            _this.thfModalService.modalActive = _this.thfModalService.modalActive || _this.id;
            /** @type {?} */
            var modalElement = _this.modalContent.nativeElement;
            if (!modalElement.contains(event.target) && _this.thfModalService.modalActive === _this.id) {
                event.stopPropagation();
                _this.firstElement.focus();
            }
        };
        this.setFirstElement();
        if (this.hideClose) {
            this.firstElement.focus();
        }
        else {
            /** @type {?} */
            var firstFieldElement = this.modalContent.nativeElement.querySelectorAll(this.focusableElements)[1] ||
                this.modalContent.nativeElement;
            firstFieldElement.focus();
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfModalComponent.prototype.setFirstElement = /**
     * @private
     * @return {?}
     */
    function () {
        this.firstElement = this.modalContent.nativeElement.querySelector(this.focusableElements) || this.modalContent.nativeElement;
    };
    ThfModalComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-modal', template: "<div *ngIf=\"!isHidden\" class=\"thf-modal\" tabindex=\"0\" (keydown.esc)=\"closeModalOnEscapeKey($event)\"> <div class=\"thf-modal-overlay\"> <div class=\"thf-modal-container thf-pb-2 thf-pt-2\" (click)=\"onClickOut($event)\"> <div class=\"thf-modal-vertical-align\"> <div #modalContent class=\"thf-modal-content thf-modal-{{ size }}\" tabindex=\"-1\"> <div class=\"thf-modal-header\"> <div class=\"thf-modal-title\"> <a *ngIf=\"!hideClose\" class=\"thf-modal-header-close-button\" tabindex=\"0\" (click)=\"close(true)\"> <span class=\"thf-icon thf-icon-close\"></span> </a> {{ title }} </div> </div> <div class=\"thf-modal-body\"> <ng-content></ng-content> </div> <div class=\"thf-modal-footer\"> <thf-button *ngIf=\"secondaryAction\" [t-disabled]=\"secondaryAction.disabled\" [t-label]=\"secondaryAction.label\" [t-loading]=\"secondaryAction.loading\" [t-type]=\"getSecondaryActionButtonType()\" (t-click)=\"secondaryAction.action()\"> </thf-button> <thf-button class=\"thf-button-modal-first-action\" [t-disabled]=\"primaryAction.disabled\" [t-label]=\"primaryAction.label\" [t-loading]=\"primaryAction.loading\" [t-type]=\"getPrimaryActionButtonType()\" (t-click)=\"primaryAction.action()\"> </thf-button> </div> </div> </div> </div> </div> </div> "
                },] },
    ];
    /** @nocollapse */
    ThfModalComponent.ctorParameters = function () { return [
        { type: ThfModalService }
    ]; };
    ThfModalComponent.propDecorators = {
        modalContent: [{ type: core.ViewChild, args: ['modalContent', { read: core.ElementRef },] }]
    };
    return ThfModalComponent;
}(ThfModalBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente thf-modal
 */
var ThfModalModule = /** @class */ (function () {
    function ThfModalModule() {
    }
    ThfModalModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        ThfButtonModule
                    ],
                    declarations: [
                        ThfModalComponent
                    ],
                    exports: [ThfModalComponent],
                    providers: [ThfModalService]
                },] },
    ];
    return ThfModalModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do componente thf-popup.
 */
var ThfPopupModule = /** @class */ (function () {
    function ThfPopupModule() {
    }
    ThfPopupModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                    ],
                    declarations: [
                        ThfPopupComponent,
                    ],
                    exports: [
                        ThfPopupComponent
                    ],
                    providers: [],
                    schemas: []
                },] },
    ];
    return ThfPopupModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Pipe responsável por apresentar um horário baseado no formato de entrada definido na API da Totvs.
 */
var ThfTimePipe = /** @class */ (function () {
    function ThfTimePipe() {
    }
    /**
     * @param {?} time
     * @param {?=} format
     * @return {?}
     */
    ThfTimePipe.prototype.transform = /**
     * @param {?} time
     * @param {?=} format
     * @return {?}
     */
    function (time, format) {
        /** @type {?} */
        var hourRegex = /^(([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9][\.]?([0-9]{1,6})?$/g;
        if (isTypeof(time, 'string') && hourRegex.test(time)) {
            /** @type {?} */
            var amountOfF = format ? format.lastIndexOf('f') - format.indexOf('f') + 1 : 0;
            /** @type {?} */
            var miliseconds = this.addDotMiliseconds(time.substring(9, 9 + amountOfF), amountOfF);
            /** @type {?} */
            var formatMiliseconds = this.getFormatMiliseconds(amountOfF);
            return this.formatValue(time, format, formatMiliseconds, miliseconds);
        }
        return null;
    };
    /**
     * @private
     * @param {?} miliseconds
     * @param {?} amountOfF
     * @return {?}
     */
    ThfTimePipe.prototype.addDotMiliseconds = /**
     * @private
     * @param {?} miliseconds
     * @param {?} amountOfF
     * @return {?}
     */
    function (miliseconds, amountOfF) {
        if (miliseconds && amountOfF) {
            miliseconds = '.' + miliseconds;
        }
        return miliseconds;
    };
    /**
     * @private
     * @param {?} time
     * @param {?} format
     * @param {?} formatMiliseconds
     * @param {?} miliseconds
     * @return {?}
     */
    ThfTimePipe.prototype.formatValue = /**
     * @private
     * @param {?} time
     * @param {?} format
     * @param {?} formatMiliseconds
     * @param {?} miliseconds
     * @return {?}
     */
    function (time, format, formatMiliseconds, miliseconds) {
        if (time && format) {
            /** @type {?} */
            var hour = time.substring(0, 2);
            /** @type {?} */
            var minutes = time.substring(3, 5);
            /** @type {?} */
            var seconds = time.substring(6, 8);
            format = format.replace('HH', hour);
            format = format.replace('mm', minutes);
            format = format.replace('ss', seconds);
            format = format.replace("." + formatMiliseconds, miliseconds);
            return format;
        }
        else {
            return time;
        }
    };
    /**
     * @private
     * @param {?} amountOfF
     * @return {?}
     */
    ThfTimePipe.prototype.getFormatMiliseconds = /**
     * @private
     * @param {?} amountOfF
     * @return {?}
     */
    function (amountOfF) {
        /** @type {?} */
        var formatMiliseconds = '';
        for (var i = 0; i < amountOfF; i++) {
            formatMiliseconds += 'f';
        }
        return formatMiliseconds;
    };
    ThfTimePipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'thf_time'
                },] },
    ];
    return ThfTimePipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo do pipe `thf-time`.
 */
var ThfTimeModule = /** @class */ (function () {
    function ThfTimeModule() {
    }
    ThfTimeModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        ThfTimePipe
                    ],
                    imports: [],
                    exports: [
                        ThfTimePipe
                    ],
                    providers: [],
                    bootstrap: []
                },] },
    ];
    return ThfTimeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CONTENT_MAX_LENGTH = 140;
/** @type {?} */
var THF_TOOLTIP_POSITION_DEFAULT = 'bottom';
/**
 * \@description
 *
 * A diretiva thf-tooltip deve ser utilizada para oferecer informações adicionais quando os usuários
 * passam o mouse sobre o elemento alvo ao qual ela está atribuída.
 *
 * O conteúdo é formado por um pequeno texto que deve contribuir para uma tomada de decisão ou
 * orientação do usuário. A ativação dele pode estar em qualquer componente ou tag HTML.
 *
 * Para textos maiores ou no caso de haver a necessidade de utilizar algum outro elemento como
 * conteúdo deve-se utilizar o [**thf-popover**](https://thf.totvs.com.br/documentation/thf-popover?view=doc).
 */
var ThfTooltipBaseDirective = /** @class */ (function () {
    function ThfTooltipBaseDirective() {
        this._tooltip = '';
        this._tooltipPosition = 'bottom';
    }
    Object.defineProperty(ThfTooltipBaseDirective.prototype, "tooltip", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tooltip;
        },
        /**
         * @description
         *
         * Habilita e atribui um texto ao thf-tooltip, com limitação de 140 caracteres.
         */
        set: /**
         * \@description
         *
         * Habilita e atribui um texto ao thf-tooltip, com limitação de 140 caracteres.
         * @param {?} tooltip
         * @return {?}
         */
        function (tooltip) {
            if (tooltip && tooltip.length > CONTENT_MAX_LENGTH) {
                this._tooltip = tooltip.substring(0, CONTENT_MAX_LENGTH);
            }
            else {
                this._tooltip = tooltip;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTooltipBaseDirective.prototype, "tooltipPosition", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tooltipPosition;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define a posição que o thf-tooltip abrirá em relação ao componente alvo. Sugere-se que seja
         * usada a orientação "bottom" (abaixo), porém o mesmo é flexível e será rotacionado
         * automaticamente para se adequar a tela, caso necessário.
         *
         * Posições válidas:
         * - `right`: Posiciona o thf-tooltip no lado direito do componente alvo.
         * - `right-bottom`: Posiciona o thf-tooltip no lado direito inferior do componente alvo.
         * - `right-top`: Posiciona o thf-tooltip no lado direito superior do componente alvo.
         * - `bottom`: Posiciona o thf-tooltip abaixo do componente alvo.
         * - `bottom-left`: Posiciona o thf-tooltip abaixo e à esquerda do componente alvo.
         * - `bottom-right`: Posiciona o thf-tooltip abaixo e à direita do componente alvo.
         * - `left`: Posiciona o thf-tooltip no lado esquerdo do componente alvo.
         * - `left-top`: Posiciona o thf-tooltip no lado esquerdo superior do componente alvo.
         * - `left-bottom`: Posiciona o thf-tooltip no lado esquerdo inferior do componente alvo.
         * - `top`: Posiciona o thf-tooltip acima do componente alvo.
         * - `top-right`: Posiciona o thf-tooltip acima e à direita do componente alvo.
         * - `top-left`: Posiciona o thf-tooltip acima e à esquerda do componente alvo.
         *
         * @default bottom
         */
        set: /**
         * \@optional
         *
         * \@description
         *
         * Define a posição que o thf-tooltip abrirá em relação ao componente alvo. Sugere-se que seja
         * usada a orientação "bottom" (abaixo), porém o mesmo é flexível e será rotacionado
         * automaticamente para se adequar a tela, caso necessário.
         *
         * Posições válidas:
         * - `right`: Posiciona o thf-tooltip no lado direito do componente alvo.
         * - `right-bottom`: Posiciona o thf-tooltip no lado direito inferior do componente alvo.
         * - `right-top`: Posiciona o thf-tooltip no lado direito superior do componente alvo.
         * - `bottom`: Posiciona o thf-tooltip abaixo do componente alvo.
         * - `bottom-left`: Posiciona o thf-tooltip abaixo e à esquerda do componente alvo.
         * - `bottom-right`: Posiciona o thf-tooltip abaixo e à direita do componente alvo.
         * - `left`: Posiciona o thf-tooltip no lado esquerdo do componente alvo.
         * - `left-top`: Posiciona o thf-tooltip no lado esquerdo superior do componente alvo.
         * - `left-bottom`: Posiciona o thf-tooltip no lado esquerdo inferior do componente alvo.
         * - `top`: Posiciona o thf-tooltip acima do componente alvo.
         * - `top-right`: Posiciona o thf-tooltip acima e à direita do componente alvo.
         * - `top-left`: Posiciona o thf-tooltip acima e à esquerda do componente alvo.
         *
         * \@default bottom
         * @param {?} position
         * @return {?}
         */
        function (position) {
            this._tooltipPosition = THF_CONTROL_POSITIONS.includes(position) ? position : THF_TOOLTIP_POSITION_DEFAULT;
        },
        enumerable: true,
        configurable: true
    });
    ThfTooltipBaseDirective.propDecorators = {
        tooltip: [{ type: core.Input, args: ['t-tooltip',] }],
        tooltipPosition: [{ type: core.Input, args: ['t-tooltip-position',] }]
    };
    return ThfTooltipBaseDirective;
}());

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsExtends ThfTooltipBaseDirective
 *
 * \@example
 *
 * <example name="thf-tooltip-basic" title="Totvs Tooltip Basic" >
 *  <file name="sample-thf-tooltip-basic/sample-thf-tooltip-basic.component.html"> </file>
 *  <file name="sample-thf-tooltip-basic/sample-thf-tooltip-basic.component.ts"> </file>
 * </example>
 *
 * <example name="thf-tooltip-labs" title="Totvs Tooltip Labs" >
 *  <file name="sample-thf-tooltip-labs/sample-thf-tooltip-labs.component.html"> </file>
 *  <file name="sample-thf-tooltip-labs/sample-thf-tooltip-labs.component.ts"> </file>
 * </example>
 *
 * <example name="thf-tooltip-new-user" title="Totvs Tooltip - New User" >
 *  <file name="sample-thf-tooltip-new-user/sample-thf-tooltip-new-user.component.html"> </file>
 *  <file name="sample-thf-tooltip-new-user/sample-thf-tooltip-new-user.component.ts"> </file>
 * </example>
 *
 */
var ThfTooltipDirective = /** @class */ (function (_super) {
    __extends$7(ThfTooltipDirective, _super);
    function ThfTooltipDirective(elementRef, renderer, thfControlPosition) {
        var _this = _super.call(this) || this;
        _this.elementRef = elementRef;
        _this.renderer = renderer;
        _this.thfControlPosition = thfControlPosition;
        _this.tooltipOffset = 8;
        return _this;
    }
    /**
     * @return {?}
     */
    ThfTooltipDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initScrollEventListenerFunction();
    };
    /**
     * @return {?}
     */
    ThfTooltipDirective.prototype.onMouseEnter = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            if (_this.tooltip) {
                _this.tooltipContent ? _this.showTooltip() : _this.createTooltip();
                _this.removeArrow(_this.arrowDirection);
                _this.thfControlPosition.adjustPosition(_this.tooltipPosition);
                _this.arrowDirection = _this.thfControlPosition.getArrowDirection();
                _this.addArrow(_this.arrowDirection);
                _this.lastTooltipText = _this.tooltip;
            }
        });
    };
    /**
     * @return {?}
     */
    ThfTooltipDirective.prototype.onMouseLeave = /**
     * @return {?}
     */
    function () {
        this.hideTooltip();
    };
    /**
     * @private
     * @param {?} arrowDirection
     * @return {?}
     */
    ThfTooltipDirective.prototype.addArrow = /**
     * @private
     * @param {?} arrowDirection
     * @return {?}
     */
    function (arrowDirection) {
        this.renderer.addClass(this.divArrow, "thf-arrow-" + arrowDirection);
    };
    /**
     * @private
     * @return {?}
     */
    ThfTooltipDirective.prototype.addScrollEventListener = /**
     * @private
     * @return {?}
     */
    function () {
        window.addEventListener('scroll', this.eventListenerFunction, true);
    };
    // Monta a estrutura do tooltip
    // Monta a estrutura do tooltip
    /**
     * @private
     * @return {?}
     */
    ThfTooltipDirective.prototype.createTooltip = 
    // Monta a estrutura do tooltip
    /**
     * @private
     * @return {?}
     */
    function () {
        this.tooltipContent = this.renderer.createElement('div');
        this.renderer.addClass(this.tooltipContent, 'thf-tooltip');
        this.divArrow = this.renderer.createElement('div');
        this.renderer.addClass(this.divArrow, 'thf-tooltip-arrow');
        this.divContent = this.renderer.createElement('div');
        this.renderer.addClass(this.divContent, 'thf-tooltip-content');
        this.textContent = this.renderer.createText(this.tooltip);
        this.renderer.appendChild(this.divContent, this.textContent);
        this.renderer.appendChild(this.tooltipContent, this.divArrow);
        this.renderer.appendChild(this.tooltipContent, this.divContent);
        this.renderer.appendChild(this.elementRef.nativeElement, this.tooltipContent);
        this.thfControlPosition.setElements(this.tooltipContent, this.tooltipOffset, this.elementRef);
        this.addScrollEventListener();
    };
    /**
     * @private
     * @return {?}
     */
    ThfTooltipDirective.prototype.initScrollEventListenerFunction = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.eventListenerFunction = function () {
            if (!_this.isHidden) {
                setTimeout(function () {
                    _this.thfControlPosition.adjustPosition(_this.tooltipPosition);
                });
            }
        };
    };
    /**
     * @private
     * @return {?}
     */
    ThfTooltipDirective.prototype.hideTooltip = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.tooltipContent) {
            this.renderer.addClass(this.tooltipContent, 'thf-invisible');
            this.isHidden = true;
            this.removeScrollEventListener();
        }
    };
    /**
     * @private
     * @param {?} arrowDirection
     * @return {?}
     */
    ThfTooltipDirective.prototype.removeArrow = /**
     * @private
     * @param {?} arrowDirection
     * @return {?}
     */
    function (arrowDirection) {
        if (this.elementRef.nativeElement.querySelector(".thf-arrow-" + arrowDirection)) {
            this.renderer.removeClass(this.divArrow, "thf-arrow-" + arrowDirection);
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfTooltipDirective.prototype.removeScrollEventListener = /**
     * @private
     * @return {?}
     */
    function () {
        window.removeEventListener('scroll', this.eventListenerFunction, true);
    };
    /**
     * @private
     * @return {?}
     */
    ThfTooltipDirective.prototype.showTooltip = /**
     * @private
     * @return {?}
     */
    function () {
        this.renderer.removeClass(this.tooltipContent, 'thf-invisible');
        this.updateTextContent();
        this.isHidden = false;
        this.addScrollEventListener();
    };
    /**
     * @private
     * @return {?}
     */
    ThfTooltipDirective.prototype.updateTextContent = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.lastTooltipText !== this.tooltip) {
            this.renderer.removeChild(this.divContent, this.textContent);
            this.textContent = this.renderer.createText(this.tooltip);
            this.renderer.appendChild(this.divContent, this.textContent);
        }
    };
    ThfTooltipDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[t-tooltip]',
                    providers: [ThfControlPositionService]
                },] },
    ];
    /** @nocollapse */
    ThfTooltipDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: ThfControlPositionService }
    ]; };
    ThfTooltipDirective.propDecorators = {
        onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: core.HostListener, args: ['mouseleave',] }]
    };
    return ThfTooltipDirective;
}(ThfTooltipBaseDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 *
 * Módulo da diretiva Thf-Tooltip.
 */
var ThfTooltipModule = /** @class */ (function () {
    function ThfTooltipModule() {
    }
    ThfTooltipModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [ThfTooltipDirective],
                    exports: [ThfTooltipDirective]
                },] },
    ];
    return ThfTooltipModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente responsável por exibir ícones nas colunas.
 */
var ThfTableColumnIconComponent = /** @class */ (function () {
    function ThfTableColumnIconComponent() {
    }
    Object.defineProperty(ThfTableColumnIconComponent.prototype, "icons", {
        get: /**
         * @return {?}
         */
        function () {
            return this._icons;
        },
        /** Lista de um ou mais ícones que serão exibidos em sua respectiva coluna. */
        set: /**
         * Lista de um ou mais ícones que serão exibidos em sua respectiva coluna.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._icons = this.convertToColumnIcon(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} columnIcon
     * @return {?}
     */
    ThfTableColumnIconComponent.prototype.getIconColorClass = /**
     * @param {?} columnIcon
     * @return {?}
     */
    function (columnIcon) {
        /** @type {?} */
        var color = this.getIconColor(columnIcon) || this.getIconColor(this.column);
        return color ? "thf-column-text-" + color : '';
    };
    /**
     * @param {?} iconColumn
     * @return {?}
     */
    ThfTableColumnIconComponent.prototype.onIconClick = /**
     * @param {?} iconColumn
     * @return {?}
     */
    function (iconColumn) {
        if (iconColumn.action) {
            iconColumn.action(this.row, iconColumn);
        }
        else if (this.column.action) {
            this.column.action(this.row, iconColumn || this.column);
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    ThfTableColumnIconComponent.prototype.convertToColumnIcon = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value instanceof Array) {
            return value.map(function (val) {
                return typeof val === 'string' ? { value: val } : val;
            });
        }
        if (typeof value === 'string') {
            return [{ value: value }];
        }
        return [];
    };
    /**
     * @private
     * @param {?} column
     * @return {?}
     */
    ThfTableColumnIconComponent.prototype.getIconColor = /**
     * @private
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return typeof column.color === 'function' ? column.color(this.row, column) : column.color;
    };
    ThfTableColumnIconComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-table-column-icon', template: "<ng-container *ngFor=\"let iconColumn of icons\"> <span class=\"thf-icon\" [class.thf-clickable]=\"iconColumn.action || column.action\" [ngClass]=\"[getIconColorClass(iconColumn), iconColumn.icon || iconColumn.value]\" (click)=\"onIconClick(iconColumn)\"> </span> </ng-container> "
                },] },
    ];
    ThfTableColumnIconComponent.propDecorators = {
        column: [{ type: core.Input, args: ['t-column',] }],
        icons: [{ type: core.Input, args: ['t-icons',] }],
        row: [{ type: core.Input, args: ['t-row',] }]
    };
    return ThfTableColumnIconComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var ThfColorPaletteEnum = {
    /** #0c9abe */
    Color01: 'color-01',
    /** #2c85c8 */
    Color02: 'color-02',
    /** #2c43c8 */
    Color03: 'color-03',
    /** #5843c8 */
    Color04: 'color-04',
    /** #ab43c8 */
    Color05: 'color-05',
    /** #ab4391 */
    Color06: 'color-06',
    /** #c64840 */
    Color07: 'color-07',
    /** #ea9b3e */
    Color08: 'color-08',
    /** #abc249 */
    Color09: 'color-09',
    /** #56b96b */
    Color10: 'color-10',
    /** #00b28e */
    Color11: 'color-11',
    /** #06a6a5 */
    Color12: 'color-12',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ThfColorPaletteService = /** @class */ (function () {
    function ThfColorPaletteService() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    ThfColorPaletteService.prototype.getColor = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return ((/** @type {?} */ (Object))).values(ThfColorPaletteEnum).includes(value.color) ?
            value.color : this.getColorFromType(value.type || value.color);
    };
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    ThfColorPaletteService.prototype.getColorFromType = /**
     * @private
     * @param {?} type
     * @return {?}
     */
    function (type) {
        switch (type) {
            case 'danger':
                return ThfColorPaletteEnum.Color07;
            case 'success':
                return ThfColorPaletteEnum.Color11;
            case 'warning':
                return ThfColorPaletteEnum.Color08;
            default:
                return ThfColorPaletteEnum.Color01;
        }
    };
    ThfColorPaletteService.decorators = [
        { type: core.Injectable },
    ];
    return ThfColorPaletteService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para a criação da representação da legenda, em formato de texto .
 */
var ThfTableColumnLabelComponent = /** @class */ (function () {
    function ThfTableColumnLabelComponent(thfColorPaletteService) {
        this.thfColorPaletteService = thfColorPaletteService;
    }
    Object.defineProperty(ThfTableColumnLabelComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        /** Objeto com os dados do label */
        set: /**
         * Objeto com os dados do label
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                value.color = this.thfColorPaletteService.getColor(value);
            }
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    ThfTableColumnLabelComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-table-column-label', template: "<span [class]=\"'thf-table-column-label thf-' + value?.color\"> {{ value?.label }} </span> "
                },] },
    ];
    /** @nocollapse */
    ThfTableColumnLabelComponent.ctorParameters = function () { return [
        { type: ThfColorPaletteService }
    ]; };
    ThfTableColumnLabelComponent.propDecorators = {
        value: [{ type: core.Input, args: ['t-value',] }]
    };
    return ThfTableColumnLabelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente responsável por apresentar o detalhe de cada linha da tabela.
 */
var ThfTableDetailComponent = /** @class */ (function () {
    function ThfTableDetailComponent(decimalPipe) {
        this.decimalPipe = decimalPipe;
        /**
         * Define se a tabela possui a opção de `checkbox` habilitada.
         */
        this.hasCheckbox = false;
        /**
         * Ação executada ao selecionar ou desmarcar a seleção de uma linha de detalhe do `thf-table`.
         */
        this.selectRow = new core.EventEmitter();
    }
    Object.defineProperty(ThfTableDetailComponent.prototype, "detail", {
        get: /**
         * @return {?}
         */
        function () {
            return this._detail;
        },
        /**
         * Configuração da linha de detalhes.
         */
        set: /**
         * Configuração da linha de detalhes.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._detail = this.returnThfTableDetailObject(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableDetailComponent.prototype, "detailColumns", {
        get: /**
         * @return {?}
         */
        function () {
            return this.detail && this.detail.columns || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableDetailComponent.prototype, "typeHeaderInline", {
        get: /**
         * @return {?}
         */
        function () {
            return this.detail && !this.detail['typeHeader'] || this.detail['typeHeader'] === 'inline';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfTableDetailComponent.prototype, "typeHeaderTop", {
        get: /**
         * @return {?}
         */
        function () {
            return this.detail && this.detail['typeHeader'] === 'top';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    ThfTableDetailComponent.prototype.formatNumberDetail = /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    function (value, format) {
        if (!format) {
            return value;
        }
        return this.decimalPipe.transform(value, format);
    };
    /**
     * @param {?} detail
     * @return {?}
     */
    ThfTableDetailComponent.prototype.getColumnTitleLabel = /**
     * @param {?} detail
     * @return {?}
     */
    function (detail) {
        return detail.label || capitalizeFirstLetter(detail.property);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    ThfTableDetailComponent.prototype.onSelectRow = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        item.$selected = !item.$selected;
        this.selectRow.emit(item);
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    ThfTableDetailComponent.prototype.returnThfTableDetailObject = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value && isTypeof(value, 'object')) {
            if (value.columns) {
                value.columns.forEach(function (column) { return column.property = column.property || column.column; });
            }
            if (Array.isArray(value)) {
                return { columns: value };
            }
            if (value.columns) {
                return value;
            }
        }
    };
    ThfTableDetailComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-table-detail', template: "<table class=\"thf-table-master-detail\"> <thead *ngIf=\"typeHeaderTop\"> <tr> <th class=\"thf-table-header thf-table-column-checkbox\" *ngIf=\"hasCheckbox\"></th> <th class=\"thf-table-header thf-table-header-column thf-table-header-master-detail\"></th> <th class=\"thf-table-header thf-table-header-ellipsis\" *ngFor=\"let detail of detail.columns\"> {{ getColumnTitleLabel(detail) }} </th> </tr> </thead> <tbody> <tr class=\"thf-table-detail-row\" [class.thf-table-row-active]=\"item.$selected && hasCheckbox\" *ngFor=\"let item of items\"> <ng-container *ngIf=\"hasCheckbox; else masterDetailSpace\"> <td class=\"thf-table-column-master-detail-space-checkbox\"></td> <td class=\"thf-table-column thf-table-column-checkbox\"> <input class=\"thf-table-checkbox\" type=\"checkbox\" [class.thf-table-checkbox-checked]=\"item.$selected\"> <label class=\"thf-table-checkbox-label thf-clickable\" (click)=\"onSelectRow(item)\"> </label> </td> </ng-container> <ng-template #masterDetailSpace> <td class=\"thf-table-column-master-detail-space\"></td> </ng-template> <td class=\"thf-table-column-master-detail thf-table-master-detail-label\" (click)=\"hasCheckbox ? onSelectRow(item) : 'javascript:;'\" *ngFor=\"let detail of detailColumns\"> <strong *ngIf=\"typeHeaderInline\"> {{ getColumnTitleLabel(detail) }}: </strong> <ng-container [ngSwitch]=\"detail.type\"> <span *ngSwitchCase=\"'currency'\">{{ item[detail.property] | currency: detail.format:'symbol':'1.2-2' }}</span> <span *ngSwitchCase=\"'date'\">{{ item[detail.property] | date: detail.format || 'dd/MM/yyyy' }}</span> <span *ngSwitchCase=\"'time'\">{{ item[detail.property] | thf_time: detail.format || 'HH:mm:ss.ffffff' }}</span> <span *ngSwitchCase=\"'dateTime'\">{{ item[detail.property] | date: detail.format || 'dd/MM/yyyy HH:mm:ss' }}</span> <span *ngSwitchCase=\"'number'\">{{ formatNumberDetail(item[detail.property], detail.format) }}</span> <span *ngSwitchDefault>{{ item[detail.property] }}</span> </ng-container> </td> </tr> </tbody> </table> "
                },] },
    ];
    /** @nocollapse */
    ThfTableDetailComponent.ctorParameters = function () { return [
        { type: common.DecimalPipe }
    ]; };
    ThfTableDetailComponent.propDecorators = {
        hasCheckbox: [{ type: core.Input, args: ['t-checkbox',] }],
        detail: [{ type: core.Input, args: ['t-detail',] }],
        items: [{ type: core.Input, args: ['t-items',] }],
        selectRow: [{ type: core.Output, args: ['t-select-row',] }]
    };
    return ThfTableDetailComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para a criação de um botão e modal para visualização de todas as legendas.
 */
var ThfTableShowSubtitleComponent = /** @class */ (function () {
    function ThfTableShowSubtitleComponent() {
    }
    ThfTableShowSubtitleComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-table-show-subtitle', template: "<div class=\"thf-table-footer-show-subtitle\" (click)=\"modal.open()\"> <div class=\"thf-table-footer-show-subtitle-container\"> <span class=\"thf-table-show-subtitle\">{{ literals.seeCompleteSubtitle }}</span> </div> </div> <thf-modal #modal t-size=\"sm\" [t-title]=\"literals.completeSubtitle\"> <div *ngFor=\"let subtitle of subtitles\" class=\"thf-table-subtitle-footer-modal thf-row\"> <thf-table-subtitle-circle t-hide-title=\"true\" [t-subtitle]=\"subtitle\"> </thf-table-subtitle-circle> <span class=\"thf-table-subtitle-text\">{{ subtitle.label }}</span> </div> </thf-modal> "
                },] },
    ];
    ThfTableShowSubtitleComponent.propDecorators = {
        subtitles: [{ type: core.Input, args: ['t-subtitles',] }],
        literals: [{ type: core.Input, args: ['t-literals',] }]
    };
    return ThfTableShowSubtitleComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para a criação da representação da legenda, em formato de círculo.
 */
var ThfTableSubtitleCircleComponent = /** @class */ (function () {
    function ThfTableSubtitleCircleComponent(thfColorPaletteService) {
        this.thfColorPaletteService = thfColorPaletteService;
        /**
         * Esconde a tooltip.
         */
        this.hideTitle = false;
    }
    Object.defineProperty(ThfTableSubtitleCircleComponent.prototype, "subtitle", {
        get: /**
         * @return {?}
         */
        function () {
            return this._subtitle;
        },
        /** Objeto com os dados da legenda. */
        set: /**
         * Objeto com os dados da legenda.
         * @param {?} subtitle
         * @return {?}
         */
        function (subtitle) {
            if (subtitle) {
                subtitle.color = this.thfColorPaletteService.getColor(subtitle);
            }
            this._subtitle = subtitle;
        },
        enumerable: true,
        configurable: true
    });
    ThfTableSubtitleCircleComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-table-subtitle-circle', template: "<span [title]=\"hideTitle ? '' : subtitle?.label\" class=\"thf-table-subtitle-circle thf-{{ subtitle?.color }}\"> {{ subtitle?.content }} </span> "
                },] },
    ];
    /** @nocollapse */
    ThfTableSubtitleCircleComponent.ctorParameters = function () { return [
        { type: ThfColorPaletteService }
    ]; };
    ThfTableSubtitleCircleComponent.propDecorators = {
        subtitle: [{ type: core.Input, args: ['t-subtitle',] }],
        hideTitle: [{ type: core.Input, args: ['t-hide-title',] }]
    };
    return ThfTableSubtitleCircleComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Componente para a criação de um conjunto de legendas.
 */
var ThfTableSubtitleFooterComponent = /** @class */ (function () {
    function ThfTableSubtitleFooterComponent(element, renderer) {
        this.element = element;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    ThfTableSubtitleFooterComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.initializeResizeListener();
        this.debounceResize();
    };
    /**
     * @return {?}
     */
    ThfTableSubtitleFooterComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeResizeListener();
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableSubtitleFooterComponent.prototype.debounceResize = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        clearTimeout(this.timeoutResize);
        this.timeoutResize = setTimeout(function () {
            _this.toggleShowCompleteSubtitle();
        });
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableSubtitleFooterComponent.prototype.getContainerSize = /**
     * @private
     * @return {?}
     */
    function () {
        return this.element.nativeElement.querySelector('.thf-table-subtitle-footer-container').offsetWidth;
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableSubtitleFooterComponent.prototype.getItemsSize = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var items = this.element.nativeElement.querySelectorAll('.thf-table-subtitle-footer');
        return Array.from(items).map(function (item) { return item['offsetWidth']; }).reduce(function (a, b) { return a + b; }, 16);
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableSubtitleFooterComponent.prototype.initializeResizeListener = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.resizeListener = this.renderer.listen('window', 'resize', function (event) {
            _this.debounceResize();
        });
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableSubtitleFooterComponent.prototype.removeResizeListener = /**
     * @private
     * @return {?}
     */
    function () {
        this.resizeListener();
    };
    /**
     * @private
     * @return {?}
     */
    ThfTableSubtitleFooterComponent.prototype.toggleShowCompleteSubtitle = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var containerSize = this.getContainerSize();
        /** @type {?} */
        var itemsSize = this.getItemsSize();
        this.showSubtitle = itemsSize > containerSize;
    };
    ThfTableSubtitleFooterComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'thf-table-subtitle-footer', template: "<div class=\"thf-table-subtitle-footer-container\"> <div *ngFor=\"let subtitle of subtitles\" class=\"thf-table-subtitle-footer\"> <thf-table-subtitle-circle t-hide-title=\"true\" [t-subtitle]=\"subtitle\"> </thf-table-subtitle-circle> <span class=\"thf-table-subtitle-text\">{{ subtitle.label }}</span> </div> <thf-table-show-subtitle *ngIf=\"showSubtitle\" [t-literals]=\"literals\" [t-subtitles]=\"subtitles\"> </thf-table-show-subtitle> </div> "
                },] },
    ];
    /** @nocollapse */
    ThfTableSubtitleFooterComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 }
    ]; };
    ThfTableSubtitleFooterComponent.propDecorators = {
        literals: [{ type: core.Input, args: ['t-literals',] }],
        subtitles: [{ type: core.Input, args: ['t-subtitles',] }]
    };
    return ThfTableSubtitleFooterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * Módulo do componente thf-table
 */
var ThfTableModule = /** @class */ (function () {
    function ThfTableModule() {
    }
    ThfTableModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        router.RouterModule,
                        ThfButtonModule,
                        ThfContainerModule,
                        ThfLoadingModule,
                        ThfModalModule,
                        ThfPopupModule,
                        ThfTimeModule,
                        ThfTooltipModule
                    ],
                    declarations: [
                        ThfTableComponent,
                        ThfTableColumnIconComponent,
                        ThfTableColumnLabelComponent,
                        ThfTableDetailComponent,
                        ThfTableRowTemplateDirective,
                        ThfTableShowSubtitleComponent,
                        ThfTableSubtitleCircleComponent,
                        ThfTableSubtitleFooterComponent
                    ],
                    exports: [
                        ThfTableComponent,
                        ThfTableRowTemplateDirective
                    ],
                    providers: [common.DecimalPipe]
                },] },
    ];
    return ThfTableModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

exports.ThfTableRowTemplateDirective = ThfTableRowTemplateDirective;
exports.ThfTableComponent = ThfTableComponent;
exports.ThfTableModule = ThfTableModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));
