/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { HttpResponse } from '@angular/common/http';
import { throwError } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';
import { ThfComponentInjectorService } from '../../services/thf-component-injector/thf-component-injector.service';
import { ThfLoadingOverlayComponent } from '../../components/thf-loading/thf-loading-overlay/thf-loading-overlay.component';
import { ThfHttpRequesControltService } from './thf-http-request-control-service';
import * as i0 from "@angular/core";
import * as i1 from "./thf-http-request-control-service";
import * as i2 from "../../services/thf-component-injector/thf-component-injector.service";
/** @type {?} */
var noCountPendingRequests = 'X-Totvs-No-Count-Pending-Requests';
/** @type {?} */
var screenLock = 'X-Totvs-Screen-Lock';
/**
 * \@description
 *
 * O serviço Totvs Http Request Interceptor realiza a contabilização de requisições pendentes na aplicação.
 *
 * Existe a possibilidade de não efetuar a contabilização das requisições pendentes, utilizando o parâmetro
 * `X-Totvs-No-Count-Pending-Requests`. Para isso deve ser informado no cabeçalho da requisição com o valor `'true'`,
 * por exemplo:
 *
 * ```
 * ...
 *  const headers = { 'X-Totvs-No-Count-Pending-Requests': 'true' };
 *
 *  this.http.get(`/customers/1`, { headers: headers });
 * ...
 *
 * ```
 * Para obter a quantidade de requisições pendentes, deve inscrever-se no método `getCountPendingRequests` do
 * serviço `ThfHttpRequestInterceptorService`, com isso, ao realizar requisições utilizando `HttpClient`,
 * será retornado a quantidade de requisições pendentes.
 *
 * Também existe a possibildade de travar a tela e mostrar uma imagem de _loading_ durante o processamento de uma requisição
 * deve-se passar o parâmetro `X-Totvs-Screen-Lock` no cabeçalho da requisição com valor `'true'`.
 *
 * por exemplo:
 *
 * ```
 * ...
 *  const headers = { 'X-Totvs-Screen-Lock': 'true' };
 *
 *  this.http.get(`/customers/1`, { headers: headers });
 * ...
 *
 * ```
 * > Após a validação no interceptor, o parâmetro será removido do cabeçalho da requisição.
 *
 * Ao importar o módulo `ThfModule` na aplicação, o `thf-http-request-interceptor` é automaticamente configurado sem a necessidade
 * de qualquer configuração extra.
 *
 *
 * Segue abaixo um exemplo de uso:
 *
 * ```
 * import { HttpClient } from '\@angular/common/http';
 *
 * ...
 *
 * \@Injectable()
 * export class CustomersService {
 *
 *  headers = { 'X-Totvs-No-Count-Pending-Requests': true, 'X-Totvs-Screen-Lock': 'true' }
 *  pendingRequests: number = 0;
 *  subscription: Subscription;
 *
 *  constructor(
 *    private http: HttpClient,
 *    private httpRequestInterceptor: ThfHttpRequestInterceptorService) { }
 *
 *  ngOnDestroy(): void {
 *    this.subscription.unsubscribe();
 *  }
 *
 *  ngOnInit(): void {
 *    this.subscription = this.httpRequestInterceptor.getCountPendingRequests().subscribe(data => {
 *      this.pendingRequests = data;
 *    });
 *  }
 *
 *  getCustomers() {
 *    return this.http.get(`/customers/1`, { headers: headers });
 *  }
 *
 *  ...
 *
 * }
 * ```
 *
 * \@example
 * <example name='thf-http-request-interceptor-labs' title='Totvs Http Request Interceptor Labs'>
 *  <file name='sample-thf-http-request-interceptor-labs.component.ts'> </file>
 *  <file name='sample-thf-http-request-interceptor-labs.component.html'> </file>
 * </example>
 */
var ThfHttpRequestInterceptorService = /** @class */ (function () {
    function ThfHttpRequestInterceptorService(controlHttpRequest, thfComponentInjector) {
        this.controlHttpRequest = controlHttpRequest;
        this.thfComponentInjector = thfComponentInjector;
        this.loadingOverlayComponent = undefined;
        this.pendingRequests = 0;
        this.overlayRequests = 0;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    ThfHttpRequestInterceptorService.prototype.intercept = /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    function (request, next) {
        var _this = this;
        /** @type {?} */
        var requestClone = request.clone();
        request = this.requestCloneWithoutHeaderParam([noCountPendingRequests, screenLock], request);
        this.setCountPendingRequests(true, requestClone);
        this.setCountOverlayRequests(true, requestClone);
        return next.handle(request).pipe(tap(function (response) {
            if (response instanceof HttpResponse) {
                _this.setCountPendingRequests(false, requestClone);
                _this.setCountOverlayRequests(false, requestClone);
            }
        }), catchError(function (error) {
            _this.setCountPendingRequests(false, requestClone);
            _this.setCountOverlayRequests(false, requestClone);
            return throwError(error);
        }));
    };
    /**
     * @return {?}
     */
    ThfHttpRequestInterceptorService.prototype.getCountPendingRequests = /**
     * @return {?}
     */
    function () {
        return this.controlHttpRequest.getControlHttpRequest();
    };
    /**
     * @private
     * @return {?}
     */
    ThfHttpRequestInterceptorService.prototype.buildLoading = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.loadingOverlayComponent) {
            this.loadingOverlayComponent = this.thfComponentInjector.createComponentInApplication(ThfLoadingOverlayComponent);
            this.loadingOverlayComponent.instance.screenLock = true;
            this.loadingOverlayComponent.instance.changeDetector.detectChanges();
        }
    };
    /**
     * @private
     * @return {?}
     */
    ThfHttpRequestInterceptorService.prototype.destroyLoading = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.loadingOverlayComponent) {
            this.thfComponentInjector.destroyComponentInApplication(this.loadingOverlayComponent);
            this.loadingOverlayComponent = undefined;
        }
    };
    /**
     * @private
     * @param {?} headersParams
     * @param {?} request
     * @return {?}
     */
    ThfHttpRequestInterceptorService.prototype.requestCloneWithoutHeaderParam = /**
     * @private
     * @param {?} headersParams
     * @param {?} request
     * @return {?}
     */
    function (headersParams, request) {
        /** @type {?} */
        var isRequestClone = false;
        headersParams.forEach(function (headerParam) {
            if (request.headers.has(headerParam)) {
                request.headers.delete(headerParam);
                isRequestClone = true;
            }
        });
        return isRequestClone ? request.clone({ headers: request.headers }) : request;
    };
    /**
     * @private
     * @param {?} isIncrement
     * @param {?} request
     * @return {?}
     */
    ThfHttpRequestInterceptorService.prototype.setCountPendingRequests = /**
     * @private
     * @param {?} isIncrement
     * @param {?} request
     * @return {?}
     */
    function (isIncrement, request) {
        /** @type {?} */
        var hasCountPendingRequestHeaderParam = request.headers.has(noCountPendingRequests);
        /** @type {?} */
        var headerParam = request.headers.get(noCountPendingRequests);
        if (hasCountPendingRequestHeaderParam && (headerParam.toString().toLowerCase() === 'true')) {
            return;
        }
        this.pendingRequests += isIncrement ? 1 : -1;
        this.controlHttpRequest.send(this.pendingRequests);
    };
    /**
     * @private
     * @param {?} isIncrement
     * @param {?} request
     * @return {?}
     */
    ThfHttpRequestInterceptorService.prototype.setCountOverlayRequests = /**
     * @private
     * @param {?} isIncrement
     * @param {?} request
     * @return {?}
     */
    function (isIncrement, request) {
        /** @type {?} */
        var hasOverlayRequestHeaderParam = request.headers.has(screenLock);
        if (hasOverlayRequestHeaderParam) {
            /** @type {?} */
            var headerParam = request.headers.get(screenLock);
            if (headerParam.toString().toLowerCase() === 'false') {
                return;
            }
            this.overlayRequests += isIncrement ? 1 : -1;
            this.overlayRequests > 0 ? this.buildLoading() : this.destroyLoading();
        }
    };
    ThfHttpRequestInterceptorService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */
    ThfHttpRequestInterceptorService.ctorParameters = function () { return [
        { type: ThfHttpRequesControltService },
        { type: ThfComponentInjectorService }
    ]; };
    /** @nocollapse */ ThfHttpRequestInterceptorService.ngInjectableDef = i0.defineInjectable({ factory: function ThfHttpRequestInterceptorService_Factory() { return new ThfHttpRequestInterceptorService(i0.inject(i1.ThfHttpRequesControltService), i0.inject(i2.ThfComponentInjectorService)); }, token: ThfHttpRequestInterceptorService, providedIn: "root" });
    return ThfHttpRequestInterceptorService;
}());
export { ThfHttpRequestInterceptorService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    ThfHttpRequestInterceptorService.prototype.loadingOverlayComponent;
    /**
     * @type {?}
     * @private
     */
    ThfHttpRequestInterceptorService.prototype.pendingRequests;
    /**
     * @type {?}
     * @private
     */
    ThfHttpRequestInterceptorService.prototype.overlayRequests;
    /**
     * @type {?}
     * @private
     */
    ThfHttpRequestInterceptorService.prototype.controlHttpRequest;
    /**
     * @type {?}
     * @private
     */
    ThfHttpRequestInterceptorService.prototype.thfComponentInjector;
}
