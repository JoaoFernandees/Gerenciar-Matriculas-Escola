/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { I18N_CONFIG } from './thf-i18n-config-injection-token';
/**
 * \@description
 *
 * O serviço thfI18nService possibilita adicionar múltiplos idiomas e contextos à aplicação.
 *
 * A primeira configuração para a utilização do serviço thfI18nService é a importação do módulo
 * ThfI18nModule no módulo principal da aplicação.
 *
 * Ao importar o módulo ThfI18nModule devem ser definidos os contextos e idiomas que a aplicação
 * irá suportar, além de alguns padrões como idioma e contexto.
 *
 * No arquivo do módulo principal da aplicação deve ser definido uma constante implementando a
 * interface ThfI18nConfig. Nesta constante é possivel definir todos os contextos suportados pela
 * aplicação.
 *
 * Para cada contexto é possível definir a origem das literais, que podem ser de um serviço REST ou
 * de um objeto.
 * Exemplo:
 *
 * > Arquivo general-pt.ts
 *
 * ```
 * export const generalPt = {
 *  add: 'Adicionar',
 *  remove: 'Remover',
 *  people: '{0} Pessoas,
 *  greeting: 'Prazer, {0} {1}'
 * }
 *
 * ```
 *
 * > Arquivo general-en.ts
 *
 * ```
 * export const generalEn = {
 *  add: 'Add',
 *  remove: 'Remove',
 *  people: '{0} People,
 *  greeting: 'Nice to meet you, {0} {1}'
 * }
 *
 * ```
 *
 * ```
 * import { ThfI18nConfig } from '\@totvs/thf-ui/services/thf-i18n';
 *
 * import { generalEn } from './i18n/general-en';
 * import { generalPt } from './i18n/general-pt';
 *
 * const i18nConfig: ThfI18nConfig = {
 *   contexts: {
 *     general: {
 *       'pt-BR': generalPt,
 *       'en-US': generalEn
 *     },
 *     crm: {
 *       url: 'http://10.0.0.1:3000/api/translations/crm'
 *     }
 *   },
 *   default: {}
 * }
 * ```
 *
 * Ao optar por utilizar um serviço, deverá ser definida a URL específica do contexto,
 * como nos exemplos abaixo:
 *  - http://10.0.0.1:3000/api/translations/crm
 *  - http://10.0.0.1:3000/api/translations/general
 *
 * Os idiomas e literais serão automaticamente buscados com parâmetros na própria URL:
 * - language: o idioma será sempre passado por parâmetro e é recomendado utilizar o padrão suportado
 * pelos navegadores (pt-br, en-us)
 * - literals: as literais serão separadas por vírgula. Caso esse parâmetro não seja informado, o
 * serviço deve retornar todas as literais do idioma.
 *
 * Exemplos de requisição:
 *  - http://10.0.0.1:3000/api/translations/crm?language=pt-br
 *  - http://10.0.0.1:3000/api/translations/crm?language=pt-br&literals=add,remove,text
 *
 * > Sempre que o idioma solicitado não for encontrado, será buscado por **pt-br**.
 *
 *
 * Conforme citado anteriormente, além dos contextos, é possível definir os padrões do sistema na
 * configuração do módulo:
 *  - language (string): idioma que será buscado por padrão pelo serviço, caso não seja especificado
 * será usado o idioma do navegador do usuário.
 *  - context (string): contexto que será buscado por padrão pelo serviço, caso não seja especificado
 * será usado o primeiro contexto da lista de contextos.
 *  - cache (boolean): define se as literais buscadas no serviço deverão ser armanezadas no cache do
 * navegador, lembrando que cada navegador possui sua própria limitação de cache. Para contextos com
 * grande quantidade de literais, recomenda-se o uso de constantes ao invés de serviços, desta forma
 * não será usado o cache do navegador.
 *
 * Exemplo de padrões definidos:
 * ```
 * const i18nConfig: ThfI18nConfig = {
 *   contexts: {
 *     general: { }
 *   },
 *   default: {
 *    language: 'pt-BR',
 *    context: 'general',
 *    cache: true
 *   }
 * }
 * ```
 *
 * Depois de criada a constante de configuração, deve-se passá-la para a função "config", diretamente
 * na importação do módulo.
 * ```
 *  imports: [
 *    ...
 *    ThfModule,
 *    ThfI18nModule.config(i18nConfig)
 *  ]
 * ```
 *
 * Feito isso, está finalizada a configuração do módulo e a aplicação está apta à utilizar o serviço
 * ThfI18nService.
 *
 * Para utilizar o serviço, deve-se importá-lo em todos os componentes que necessitarem de literais:
 * ```
 *  import { ThfI18nService } from '\@totvs/thf-ui/services/thf-i18n';
 * ```
 *
 * Em seguinda, fazer a injeção de dependência no construtor do componente:
 * ```
 *  constructor(private thfI18nService: ThfI18nService) { }
 * ```
 *
 * E por fim, fazer a busca pelas literais, se inscrevendo no Observable pelo método `getLiterals()`.
 * Este método pode receber um objeto com três atributos como parâmetro:
 *  - context (string): Para definir o contexto a ser buscado.
 *  - language (string): Para escolher o idioma a ser buscado.
 *  - literals (Array&#60;string&#62;): Para escolher quais literais devem ser buscadas.
 *
 * Todos esses parâmetros são opcionais, ou seja, caso nenhum parâmetro seja passado, serão trazidas
 * todas as literais do contexto definido com padrão, no idioma definido como padrão.
 *
 * Exemplos de requisição:
 * ```
 * literals = {};
 * literalsEn = {};
 * literalsCrm = {};
 *
 * constructor(private thfI18nService: ThfI18nService) {
 *   thfI18nService.getLiterals()
 *     .subscribe((literals) => {
 *       this.literals = literals;
 *     });
 *
 *   thfI18nService.getLiterals({context: 'crm', literals: ['add', 'remove']})
 *     .subscribe((literals) => {
 *       this.literalsCrm = literals;
 *     });
 *
 *   thfI18nService.getLiterals({language: 'en-us'})
 *     .subscribe((literals) => {
 *       this.literalsEn = literals;
 *     });
 * }
 * ```
 *
 * Para apresentar as literais capturadas acima no HTML do componente, deve-se utilizar o
 * seguinte código:
 *
 * <pre ngNonBindable>
 * {{ literals?.add }}
 * {{ literals?.remove }}
 * </pre>
 *
 * Caso as literais contenham variáveis que precisem ser substituídas, pode-se utilizar o pipe thfI18n.
 * É possível informar propriedades do componente como `name` e `nickname` ou
 * informar o valor diretamente com "" ou número, confome o exemplo abaixo:
 *
 * <pre ngNonBindable>
 * {{ literals?.people | thfI18n:[120] }}
 * {{ literals?.greeting | thfI18n:[name, nickname] }}
 * {{ literals?.greeting | thfI18n:["Brad", "Green"] }}
 * </pre>
 *
 * > É importante o uso do operador `?` (Elvis) para evitar erros enquanto as literais não forem carregadas.
 *
 * ### Teste unitário
 *
 * Abaixo segue um exemplo de *setup* inicial de teste unitário do *AppComponent* que utiliza o `ThfI18nService`:
 *
 * ```
 * import { async, TestBed } from '\@angular/core/testing';
 * import { HttpClientTestingModule } from '\@angular/common/http/testing';
 *
 * import { ThfI18nModule } from '\@totvs/thf-ui/services/thf-i18n';
 *
 * import { AppComponent } from './app.component';
 *
 * describe('AppComponent', () => {
 *   const anotherPT = {
 *     text: 'texto',
 *     add: 'adicionar',
 *     remove: 'remover'
 *   };
 *
 *   const generalPT = {
 *     text: 'texto',
 *     add: 'adicionar',
 *     remove: 'remover'
 *   };
 *
 *   const config = {
 *     default: {
 *       language: 'pt-BR',
 *       context: 'general',
 *       cache: false
 *     },
 *     contexts: {
 *       general: {
 *         'pt-br': generalPT
 *       },
 *       another: {
 *         'pt-br': anotherPT
 *       }
 *     }
 *   };
 *
 *   beforeEach(async(() => {
 *     TestBed.configureTestingModule({
 *       declarations: [
 *         AppComponent
 *       ],
 *       imports: [
 *         HttpClientTestingModule,
 *         ThfI18nModule.config(config)
 *       ]
 *     }).compileComponents();
 *   }));
 *
 *   it('should create the app', async(() => {
 *     const fixture = TestBed.createComponent(AppComponent);
 *     const app = fixture.debugElement.componentInstance;
 *
 *     expect(app).toBeTruthy();
 *   }));
 *
 * });
 * ```
 */
var ThfI18nBaseService = /** @class */ (function () {
    function ThfI18nBaseService(config, http) {
        this.config = config;
        this.http = http;
        this.varI18n = {};
        this.useCache = false;
        this.servicesContext = {};
        this.setConfig(config);
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    ThfI18nBaseService.prototype.setConfig = /**
     * @private
     * @param {?} config
     * @return {?}
     */
    function (config) {
        // Seta as configurações padrões definidas no importação do módulo
        if (config['default']) {
            if (config['default']['language']) {
                this.languageDefault = config['default']['language'].toLowerCase();
            }
            else {
                this.languageDefault = navigator.language.toLowerCase();
            }
            this.contextDefault = (config['default']['context']) ? config['default']['context'] : '';
            this.useCache = (config['default']['cache']) ? config['default']['cache'] : false;
        }
        // Carrega a lista dos contextos e as contantes informadas
        if (config['contexts']) {
            this.setVarI18n(config['contexts']);
            // Se nenhum contexto foi definido como padrão,
            // então define o primeiro contexto
            if (!this.contextDefault) {
                for (var context in config['contexts']) {
                    if (this.config['contexts'].hasOwnProperty(context)) {
                        this.contextDefault = context;
                        break;
                    }
                }
            }
        }
    };
    /**
     * @param {?=} options
     * @return {?}
     */
    ThfI18nBaseService.prototype.getLiterals = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var language = (options['language']) ? options['language'].toLowerCase() : this.languageDefault.toLowerCase();
        /** @type {?} */
        var context = (options['context']) ? options['context'] : this.contextDefault;
        /** @type {?} */
        var literals = (options['literals']) ? options['literals'] : [];
        return new Observable(function (observer) {
            if (_this.servicesContext[context]) {
                // Faz o processo de busca de um contexto que contém serviço
                _this.getLiteralsFromContextService(language, context, literals, observer);
            }
            else {
                // Faz o processo de busca de um contexto que utiliza constante
                _this.getLiteralsFromContextConstant(language, context, literals, observer);
            }
        });
    };
    // Processo de busca de um contexto que contém serviço.
    //
    // Quando está definida uma lista de literais:
    //    1 - Procura na variável do serviço
    //    2 - Se não encontrar todas as literais, procura no local storage (Se o cache estiver definido
    //        como true na configuração do módulo)
    //    3 - Dispara o serviço, mesmo que já tenha encontrado no local storage, para garantir a atualização
    //    4 - Se não encontrar todas as literais desejadas e o idioma não for Português,
    //        então refaz o processo trocando o idioma para pt-BR
    //
    // Quando não está definida uma lista de literais:
    //    1 - Procura na variável do serviço
    //    2 - Procura no local storage (Se o cache estiver definido como true na configuração do módulo)
    //    3 - Dispara o serviço, mesmo que já tenha encontrado no local storage, para garantir a atualização
    //    4 - Se nenhuma literal for encontrada, então busca em pt-br
    // Processo de busca de um contexto que contém serviço.
    //
    // Quando está definida uma lista de literais:
    //    1 - Procura na variável do serviço
    //    2 - Se não encontrar todas as literais, procura no local storage (Se o cache estiver definido
    //        como true na configuração do módulo)
    //    3 - Dispara o serviço, mesmo que já tenha encontrado no local storage, para garantir a atualização
    //    4 - Se não encontrar todas as literais desejadas e o idioma não for Português,
    //        então refaz o processo trocando o idioma para pt-BR
    //
    // Quando não está definida uma lista de literais:
    //    1 - Procura na variável do serviço
    //    2 - Procura no local storage (Se o cache estiver definido como true na configuração do módulo)
    //    3 - Dispara o serviço, mesmo que já tenha encontrado no local storage, para garantir a atualização
    //    4 - Se nenhuma literal for encontrada, então busca em pt-br
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?=} translations
     * @param {?=} languageAlternative
     * @return {?}
     */
    ThfI18nBaseService.prototype.getLiteralsFromContextService = 
    // Processo de busca de um contexto que contém serviço.
    //
    // Quando está definida uma lista de literais:
    //    1 - Procura na variável do serviço
    //    2 - Se não encontrar todas as literais, procura no local storage (Se o cache estiver definido
    //        como true na configuração do módulo)
    //    3 - Dispara o serviço, mesmo que já tenha encontrado no local storage, para garantir a atualização
    //    4 - Se não encontrar todas as literais desejadas e o idioma não for Português,
    //        então refaz o processo trocando o idioma para pt-BR
    //
    // Quando não está definida uma lista de literais:
    //    1 - Procura na variável do serviço
    //    2 - Procura no local storage (Se o cache estiver definido como true na configuração do módulo)
    //    3 - Dispara o serviço, mesmo que já tenha encontrado no local storage, para garantir a atualização
    //    4 - Se nenhuma literal for encontrada, então busca em pt-br
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?=} translations
     * @param {?=} languageAlternative
     * @return {?}
     */
    function (language, context, literals, observer, translations, languageAlternative) {
        if (translations === void 0) { translations = {}; }
        if (languageAlternative === void 0) { languageAlternative = null; }
        // Idioma usado para tentar buscar as literais faltantes
        /** @type {?} */
        var languageSearch = (languageAlternative) ? languageAlternative : language;
        translations = this.mergeObject(translations, this.searchInVarI18n(languageSearch, context, literals));
        if (this.countObject(translations) > 0) {
            observer.next(translations);
        }
        // Se foi pesquisado por literais
        if (literals.length > 0) {
            // Se não encontrou todas as literais pesquisadas no idioma
            if (literals.length > this.countObject(translations)) {
                this.getLiteralsLocalStorageAndCache(languageSearch, context, literals, observer, translations, languageAlternative);
            }
        }
        else {
            this.getLiteralsLocalStorageAndCache(languageSearch, context, literals, observer, translations, languageAlternative);
        }
    };
    // Procura no local storage e em seguida no serviço
    // Caso não encontre nem no serviço, recomeça a busca em pt-br
    // Procura no local storage e em seguida no serviço
    // Caso não encontre nem no serviço, recomeça a busca em pt-br
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?} translations
     * @param {?=} languageAlternative
     * @return {?}
     */
    ThfI18nBaseService.prototype.getLiteralsLocalStorageAndCache = 
    // Procura no local storage e em seguida no serviço
    // Caso não encontre nem no serviço, recomeça a busca em pt-br
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?} translations
     * @param {?=} languageAlternative
     * @return {?}
     */
    function (language, context, literals, observer, translations, languageAlternative) {
        var _this = this;
        if (languageAlternative === void 0) { languageAlternative = null; }
        /** @type {?} */
        var languageSearch = (languageAlternative) ? languageAlternative : language;
        /** @type {?} */
        var translationTemp;
        // Verifica se usa cache
        if (this.useCache) {
            translationTemp = this.searchInLocalStorage(languageSearch, context, literals);
            if (this.countObject(translationTemp) > 0) {
                this.updateVarI18n(language, context, translationTemp);
                translations = this.mergeObject(translations, translationTemp);
                observer.next(translations);
            }
        }
        // Busca do Serviço
        this.getHttpService(this.servicesContext[context], languageSearch, literals)
            .subscribe(function (response) {
            if (response) {
                _this.updateLocalStorage(language, context, response);
                _this.updateVarI18n(language, context, response);
                translationTemp = _this.searchInVarI18n(language, context, literals);
                translations = _this.mergeObject(translations, translationTemp);
                observer.next(translations);
            }
            // Se não encontrou todas as literais pesquisadas no idioma
            // Então refaz o processo procurando em português
            if (literals.length > _this.countObject(translations)) {
                if (languageAlternative === 'pt-br') {
                    // Se não encontrou nem em português, então retorna o nome das literais
                    translations = _this.completeFaultLiterals(language, context, literals, translations);
                    _this.updateLocalStorage(language, context, translations);
                    _this.updateVarI18n(language, context, translations);
                    observer.next(translations);
                }
                else {
                    _this.getLiteralsFromContextService(language, context, literals, observer, translations, 'pt-br');
                }
            }
        });
    };
    // Procura pela lista de literais
    // Se não encontrar todas, procura em pt-br
    // Procura pela lista de literais
    // Se não encontrar todas, procura em pt-br
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?=} translations
     * @return {?}
     */
    ThfI18nBaseService.prototype.getLiteralsFromContextConstant = 
    // Procura pela lista de literais
    // Se não encontrar todas, procura em pt-br
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?=} translations
     * @return {?}
     */
    function (language, context, literals, observer, translations) {
        if (translations === void 0) { translations = {}; }
        translations = this.mergeObject(translations, this.searchInVarI18n(language, context, literals));
        if (this.countObject(translations) > 0) {
            observer.next(translations);
        }
        // Se foi pesquisado por literais
        if (literals.length > 0) {
            // Se não encontrou todas as literais pesquisadas no idioma, procura em português
            if (literals.length > this.countObject(translations)) {
                if (language === 'pt-br') {
                    // Se não encontrou nem em português, então retorna o nome das literais
                    translations = this.completeFaultLiterals(language, context, literals, translations);
                    observer.next(translations);
                }
                else {
                    this.getLiteralsFromContextConstant('pt-br', context, literals, observer, translations);
                }
            }
        }
        else {
            // Se não encontrar nenhuma literal, procura em português
            if (this.countObject(translations) === 0 && language !== 'pt-br') {
                this.getLiteralsFromContextConstant('pt-br', context, literals, observer, translations);
            }
            // caso não informar literais e não houver tradução
            observer.next(translations);
            observer.complete();
        }
    };
    // Busca pelas literais no local storage
    // Busca pelas literais no local storage
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @return {?}
     */
    ThfI18nBaseService.prototype.searchInLocalStorage = 
    // Busca pelas literais no local storage
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @return {?}
     */
    function (language, context, literals) {
        /** @type {?} */
        var translations = {};
        if (literals.length > 0) {
            for (var i = 0; i < literals.length; i++) {
                /** @type {?} */
                var literal = literals[i];
                /** @type {?} */
                var translation = localStorage.getItem(language + '-' + context + '-' + literal);
                if (translation) {
                    translations[literal] = translation;
                }
            }
        }
        return translations;
    };
    // Busca pelas literais na variável do serviço
    // Busca pelas literais na variável do serviço
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @return {?}
     */
    ThfI18nBaseService.prototype.searchInVarI18n = 
    // Busca pelas literais na variável do serviço
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @return {?}
     */
    function (language, context, literals) {
        /** @type {?} */
        var translations = {};
        if (this.varI18n[language] && this.varI18n[language][context]) {
            /** @type {?} */
            var content = this.varI18n[language][context];
            if (literals.length > 0) {
                // Busca as literais desejadas
                for (var i = 0; i < literals.length; i++) {
                    /** @type {?} */
                    var literal = literals[i];
                    if (content.hasOwnProperty(literal)) {
                        translations[literal] = content[literal];
                    }
                }
            }
            else {
                // Atribui todas as literais
                translations = content;
            }
        }
        return translations;
    };
    // Atualiza o local storage
    // Atualiza o local storage
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} data
     * @return {?}
     */
    ThfI18nBaseService.prototype.updateLocalStorage = 
    // Atualiza o local storage
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} data
     * @return {?}
     */
    function (language, context, data) {
        if (this.useCache) {
            for (var literal in data) {
                if (data.hasOwnProperty(literal)) {
                    localStorage.setItem(language + '-' + context + '-' + literal, data[literal]);
                }
            }
        }
    };
    // Atualiza a variável local com as literais com os objetos passados na configuração
    // Atualiza a variável local com as literais com os objetos passados na configuração
    /**
     * @private
     * @param {?} contexts
     * @return {?}
     */
    ThfI18nBaseService.prototype.setVarI18n = 
    // Atualiza a variável local com as literais com os objetos passados na configuração
    /**
     * @private
     * @param {?} contexts
     * @return {?}
     */
    function (contexts) {
        // Percorre os contextos
        for (var context in contexts) {
            if (contexts.hasOwnProperty(context)) {
                /** @type {?} */
                var contextContent = contexts[context];
                // Percorre os idiomas dentro do contexto
                for (var language in contextContent) {
                    if (contextContent.hasOwnProperty(language)) {
                        /** @type {?} */
                        var languageContent = contextContent[language];
                        if (language === 'url') {
                            this.servicesContext[context] = languageContent;
                        }
                        else {
                            this.updateVarI18n(language, context, languageContent);
                        }
                    }
                }
            }
        }
    };
    // Atualiza a variável local com as literais idioma e contexto
    // Atualiza a variável local com as literais idioma e contexto
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} data
     * @return {?}
     */
    ThfI18nBaseService.prototype.updateVarI18n = 
    // Atualiza a variável local com as literais idioma e contexto
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} data
     * @return {?}
     */
    function (language, context, data) {
        var _a;
        language = language.toLowerCase();
        if (!this.varI18n[language]) {
            this.varI18n[language] = (_a = {}, _a[context] = {}, _a);
        }
        if (!this.varI18n[language][context]) {
            this.varI18n[language][context] = {};
        }
        // Cria ou atualiza o contexto dentro do storage
        this.varI18n[language][context] = this.mergeObject(data, this.varI18n[language][context]);
    };
    /**
     * @private
     * @param {?} url
     * @param {?} language
     * @param {?} literals
     * @return {?}
     */
    ThfI18nBaseService.prototype.getHttpService = /**
     * @private
     * @param {?} url
     * @param {?} language
     * @param {?} literals
     * @return {?}
     */
    function (url, language, literals) {
        /** @type {?} */
        var param = '?language=' + language;
        if (literals.length > 0) {
            param += '&literals=' + literals.join();
        }
        // Remove a barra final do endereço
        url = (url.lastIndexOf('/') === url.length - 1) ? url.substr(0, url.length - 1) : url;
        return this.http.get(url + param);
    };
    // Completa com o nome da literais, as que não foram encontradas
    // Completa com o nome da literais, as que não foram encontradas
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} translations
     * @return {?}
     */
    ThfI18nBaseService.prototype.completeFaultLiterals = 
    // Completa com o nome da literais, as que não foram encontradas
    /**
     * @private
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} translations
     * @return {?}
     */
    function (language, context, literals, translations) {
        for (var i = 0; i < literals.length; i++) {
            /** @type {?} */
            var literal = literals[i];
            if (!translations[literal]) {
                translations[literal] = literal;
            }
        }
        return translations;
    };
    // Conta os atributos do objeto
    // Conta os atributos do objeto
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    ThfI18nBaseService.prototype.countObject = 
    // Conta os atributos do objeto
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        return Object.keys(obj).length;
    };
    // Faz o merge dos objetos, sempre dando preferência para o primeiro objeto de parâmetro
    // Faz o merge dos objetos, sempre dando preferência para o primeiro objeto de parâmetro
    /**
     * @private
     * @param {?} objPermanent
     * @param {?} obj
     * @return {?}
     */
    ThfI18nBaseService.prototype.mergeObject = 
    // Faz o merge dos objetos, sempre dando preferência para o primeiro objeto de parâmetro
    /**
     * @private
     * @param {?} objPermanent
     * @param {?} obj
     * @return {?}
     */
    function (objPermanent, obj) {
        for (var literal in objPermanent) {
            if (objPermanent.hasOwnProperty(literal)) {
                obj[literal] = objPermanent[literal];
            }
        }
        return obj;
    };
    /** @nocollapse */
    ThfI18nBaseService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [I18N_CONFIG,] }] },
        { type: HttpClient, decorators: [{ type: Inject, args: [HttpClient,] }] }
    ]; };
    return ThfI18nBaseService;
}());
export { ThfI18nBaseService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    ThfI18nBaseService.prototype.varI18n;
    /**
     * @type {?}
     * @private
     */
    ThfI18nBaseService.prototype.languageDefault;
    /**
     * @type {?}
     * @private
     */
    ThfI18nBaseService.prototype.contextDefault;
    /**
     * @type {?}
     * @private
     */
    ThfI18nBaseService.prototype.useCache;
    /**
     * @type {?}
     * @private
     */
    ThfI18nBaseService.prototype.servicesContext;
    /**
     * @type {?}
     * @private
     */
    ThfI18nBaseService.prototype.config;
    /**
     * @type {?}
     * @private
     */
    ThfI18nBaseService.prototype.http;
}
